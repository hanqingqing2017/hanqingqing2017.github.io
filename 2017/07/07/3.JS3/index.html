<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <meta name="description" content="面向对象JavaScript(JS)：一门轻量级的脚本“编程语言”
1、编程语言C、C++、Java、PHP、.NET(dot net)、C#、ASP、ASP.NET、Python、Ruby、Go、VB、JavaScript……
=》所有的编程语言都是面向对象开放的（C是面向过程的）
2、面向对象
" />
  

  
  
  
  
  
  
  <title>JavaScript基础总结3 | 我的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="面向对象JavaScript(JS)：一门轻量级的脚本“编程语言” 1、编程语言C、C++、Java、PHP、.NET(dot net)、C#、ASP、ASP.NET、Python、Ruby、Go、VB、JavaScript…… =》所有的编程语言都是面向对象开放的（C是面向过程的） 2、面向对象  对象：万物皆对象，它是一个泛指 类：对象的一细分 实例：某一个类别中具体的事物  生活中的例子：我">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript基础总结3">
<meta property="og:url" content="http://yoursite.com/2017/07/07/3.JS3/index.html">
<meta property="og:site_name" content="我的博客">
<meta property="og:description" content="面向对象JavaScript(JS)：一门轻量级的脚本“编程语言” 1、编程语言C、C++、Java、PHP、.NET(dot net)、C#、ASP、ASP.NET、Python、Ruby、Go、VB、JavaScript…… =》所有的编程语言都是面向对象开放的（C是面向过程的） 2、面向对象  对象：万物皆对象，它是一个泛指 类：对象的一细分 实例：某一个类别中具体的事物  生活中的例子：我">
<meta property="og:image" content="http://yoursite.com/2017/07/07/3.JS3/3-小试牛刀.png">
<meta property="og:image" content="http://yoursite.com/2017/07/07/3.JS3/6-原型模式.png">
<meta property="og:image" content="http://yoursite.com/2017/07/07/3.JS3/JS类的构建体系图.png">
<meta property="og:updated_time" content="2017-07-07T04:32:27.091Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JavaScript基础总结3">
<meta name="twitter:description" content="面向对象JavaScript(JS)：一门轻量级的脚本“编程语言” 1、编程语言C、C++、Java、PHP、.NET(dot net)、C#、ASP、ASP.NET、Python、Ruby、Go、VB、JavaScript…… =》所有的编程语言都是面向对象开放的（C是面向过程的） 2、面向对象  对象：万物皆对象，它是一个泛指 类：对象的一细分 实例：某一个类别中具体的事物  生活中的例子：我">
<meta name="twitter:image" content="http://yoursite.com/2017/07/07/3.JS3/3-小试牛刀.png">
  
  
    <link rel="icon" href="/css/images/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  

  
  <!-- baidu webmaster push -->
  <script src='//push.zhanzhang.baidu.com/push.js'></script>
</head>
<body class="home blog custom-background custom-font-enabled single-author">
  <div id="page" class="hfeed site">
      <header id="masthead" class="site-header" role="banner">
    <hgroup>
      <h1 class="site-title">
        <a href="/" title="我的博客" rel="home">我的博客</a>
      </h1>
      
        <script type="text/javascript" src="http://api.hitokoto.us/rand?encode=js&charset=utf-8"></script>
        <h2 class="site-description"><script>hitokoto();</script></h2>
      
    </hgroup>

    <nav id="site-navigation" class="main-navigation" role="navigation">
            <button class="menu-toggle">菜单</button>
            <a class="assistive-text" href="/#content" title="跳至内容">跳至内容</a><!--TODO-->
            <div class="menu-main-container">
                <ul id="menu-main" class="nav-menu">
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/">Home</a></li>
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/archives">Archives</a></li>
                
                </ul>
            </div>
    </nav>
</header>
      <div id="main" class="wrapper">
        <div id="primary" class="site-content"><div id="content" role="main"><article id="post-3.JS3" class="post-3.JS3 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title article-title">
      JavaScript基础总结3
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2017/07/07/3.JS3/" data-id="cj4v4j6cj0011t8w9si3ffgas" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p>JavaScript(JS)：一门轻量级的脚本“编程语言”</p>
<p>1、编程语言<br>C、C++、Java、PHP、.NET(dot net)、C#、ASP、ASP.NET、Python、Ruby、Go、VB、<br>JavaScript……</p>
<p>=》所有的编程语言都是面向对象开放的（C是面向过程的）</p>
<p>2、面向对象</p>
<ul>
<li>对象：万物皆对象，它是一个泛指</li>
<li>类：对象的一细分</li>
<li>实例：某一个类别中具体的事物</li>
</ul>
<p>生活中的例子：<br>我们生活在自然界中，自然界中的一切事物都是我们要研究的对象（统称为对象），而我们研究自然界的过程其实就是面向对象思想；自然界中把具有相同特点的进行分类（大类中包含小类），当我们需要研究的时候，只需要找出一个类别中的具体事物来研究即可，这个事物就是类的实例；</p>
<p>那么在JS中呢：<br>我们研究的JS中的一切事物都是对象，JS也是按照对象、类、实例三层体系架构实现的，JS把所有的东西按照特征分成了很多的大类和小类，我们要研究其中的某一个类，只需要研究里面的一个实例即可</p>
<p>Math</p>
<h4 id="gt-学习面向对象"><a href="#gt-学习面向对象" class="headerlink" title="=&gt;学习面向对象"></a>=&gt;学习面向对象</h4><p>1）学会自己创建类和实例<br>2）掌握原型机制（掌握实例和类的关系）<br>3）掌握类的继承、封装、多态<br>4）基于面向对象思想封装组件插件等</p>
<h3 id="1-面向对象"><a href="#1-面向对象" class="headerlink" title="1.面向对象"></a>1.面向对象</h3><p><strong>研究数组</strong><br>创建数组类Array的一个实例（创建数组）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var ary = [12,23];//-&gt;字面量创建方式</div><div class="line">var ary2 = new Array(&apos;12&apos;);//-&gt;实例创建方式（面向对象创建）</div><div class="line">//new Array(12) 括号中的数字是设定数组的长度，而不是给增加值</div><div class="line">//new Array(&apos;12&apos;)这样才是给数组第一项设定为12，数组有一项</div><div class="line">//new Array(12,23)这样数组有两项，分别是12和23</div><div class="line">console.dir(ary);</div><div class="line">console.dir(ary2);</div></pre></td></tr></table></figure></p>
<h3 id="2-创建类"><a href="#2-创建类" class="headerlink" title="2.创建类"></a>2.创建类</h3><p>创建的类第一个字母最好大写<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function Person()&#123;</div><div class="line">	  //看不见：var obj=&#123;&#125;  this-&gt;obj</div><div class="line">	  //看不见：return obj;/return this;</div><div class="line">&#125;</div><div class="line">	var a = Person();//-&gt;此时的Person仅仅是一个普通的函数，走的是函数那一套流程：创建私有的作用域-&gt;赋值/预解释-&gt;依次执行代码（私有变量还是全局变量=&gt;作用域链）-&gt;作用域是否销毁“生命周期”</div><div class="line">	console.log(a);//-&gt;undefined 因为函数执行的时候没有返回值</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function Person()&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">var p = new Person();</div><div class="line">console.log(p);</div></pre></td></tr></table></figure>
<p><code>var p = new Person()</code>-&gt;这样执行Person就是一个类了，它的执行步骤：<br>1.也和普通函数执行一样，创建一个私有的作用域，进行形参赋值和预解释<br>2.new 这样执行，在预解释完成后，浏览器会默认的在私有作用域中创建一个对象，而且函数中的this就指向这个对象<br>3.然后在和普通函数一样，代码从上到下执行（作用域链）<br>4.new 这样执行，在代码执行完成后，会默认的把第二步中我们创建的这个对象返回</p>
<blockquote>
<p>这种执行方式叫做构造函数模式，new Person( )  Person就是一个类（自定义类），而返回的结果P就是当前类的一个实例</p>
<p><strong>this 问题</strong><br>  普通函数执行，方法中的this取决于函数执行的时候前面是否有点“.”，有的话点前面是谁this就指向谁，没有的话this指向window</p>
<ul>
<li>构造函数模式下，方法中的this指向的是当前类的一个实例</li>
</ul>
</blockquote>
<h4 id="小试牛刀"><a href="#小试牛刀" class="headerlink" title="小试牛刀"></a>小试牛刀</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function Student(name,age) &#123;</div><div class="line">	this.name = name;</div><div class="line">	this.age = age;</div><div class="line">&#125;</div><div class="line">var st1 = new Student(&apos;赵薇&apos;，72)；</div><div class="line">var st2 = new Student(&apos;小燕子&apos;，16)；</div><div class="line">console.log(st1);</div></pre></td></tr></table></figure>
<p>student( );普通函数执行；<br>student；函数的一个定义体（函数本身）<br>var st2 = new Student;  在构造函数模式执行的时候，如果不需要传递参数，后面的小括号可加可不加，没什么区别；</p>
<blockquote>
<p>通过构造函数创建出来的实例都是相互独立的个体，互相不影响，而在构造函数体中写的this.xxx = xxx都相当于在给当前的实例增加增加属于自己的私有属性</p>
<ul>
<li>类的数据类型：函数数据类型  typeof Student=&gt;’function’</li>
<li>实例数据类型： 对象数据类型 typeof st1=&gt;’object’</li>
</ul>
</blockquote>
<p><img src="./3-小试牛刀.png" alt="Alt text"></p>
<h4 id="登堂入室"><a href="#登堂入室" class="headerlink" title="登堂入室"></a>登堂入室</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function Fn(name) &#123;</div><div class="line">	var school =&apos;大学&apos;;//-&gt;school仅仅是私有作用域中的一个私有变量，在函数体中只有this.xxx=xxx才是在给实例设置私有的属性，而私有的变量和实例没有必然的联系</div><div class="line">	this.name = name;</div><div class="line">	this.say = function () &#123;</div><div class="line">		console.log(&apos;my name is&apos; + this.name +&apos;,i study in the&apos; + school);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">var f1 = new Fn(&apos;赵薇&apos;);</div><div class="line">var f2 = new Fn(&apos;小燕子&apos;);</div><div class="line">console.log(f1.name);//赵薇</div><div class="line">f1.say( );//this指向f1 //my name is 赵薇，i study in the 珠峰</div><div class="line">console.log(f1.say === f2.say);//false 实例之间是相互独立的，this.xxx=xxx其实是给实例增加的私有的属性</div><div class="line">console.log(f1.school);//undefined 属性名不存在，获取的结果是undefined，而不是报错 =&gt;函数具备多种角色：普通函数、类、不同的角色之间没有必然的联系</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function Fn(name)&#123;</div><div class="line">	var school = &apos;大学&apos;;</div><div class="line">	this.name = name;</div><div class="line">	this.say = function ()&#123;</div><div class="line">		console.log(&apos;my name  is&apos; + this.name + &apos;,i study in the &apos; +school );</div><div class="line">	&#125;</div><div class="line">	return 1;</div><div class="line">&#125;</div><div class="line">var f1 = new Fn(&apos;赵薇&apos;);</div><div class="line">console.log(f1);//赵薇 -&gt;实例：如果我们返回的结果是一个基本数据类型值，对最后的实例没有任何的影响</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function Fn(name)&#123;</div><div class="line">	var school = &apos;大学&apos;;</div><div class="line">	this.name = name;</div><div class="line">	this.say = function()&#123;</div><div class="line">		console.log(&apos;my name is&apos;+this.name+&apos;,i study in the&apos;+school);</div><div class="line">	&#125;;</div><div class="line">	return&#123;name:&apos;大学&apos;&#125;;//没有return返回赵薇</div><div class="line">&#125;</div><div class="line">var f1 = new Fn(&apos;赵薇&apos;);</div><div class="line">console.log(f1);//大学 -&gt;新的对象：如果我们手动返回的结果是一个引用数据类型的值，会把默认返回的实例给覆盖掉，此时的f1就不是类的实例了</div><div class="line">console.log(&apos;say&apos; in f1);//true-&gt;检测say是否为f1的一个属性</div><div class="line">console.log(f1.hasOwnProperty(&apos;say&apos;));//true;-&gt;hasOwnProperty:检测属性是否为对象（实例）的私有属性</div></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>in:不管当前的属性是私有的还是公有的，只有有返回值的结果就是true</li>
<li>hasOwnProperty: 只有是私有的属性才会返回true，即使你公有里面有这个属性，但是如果私有中没有，返回结果也是false</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function Fn(name)&#123;</div><div class="line">	var school = &apos;大学&apos;；</div><div class="line">	this.name = name;</div><div class="line">	this.say = function ()&#123;</div><div class="line">		console.log(&apos;my name is&apos;+ this.name +&apos;,i study in the&apos; +school)</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">var f1 = new Fn(&apos;赵薇&apos;);</div><div class="line">//检测某一个对象是否拥有某一个公有的属性：检测attr是否为obj的公有属性</div><div class="line">function hasPublicProperty(obj,attr) &#123;</div><div class="line">	return (attr in obj) &amp;&amp; !obj.hasOwnProperty(attr);//满足条件attr是obj的一个属性并且不是私有的属性</div><div class="line">&#125;</div><div class="line">console.log (hasPublicProperty(f1,&apos;say&apos;));//false</div></pre></td></tr></table></figure>
<h4 id="5-单例模式的误区"><a href="#5-单例模式的误区" class="headerlink" title="5.单例模式的误区"></a>5.单例模式的误区</h4><p><strong>单例模式</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var personRender = &#123;&#125;;</div><div class="line">var studentRender =(function()&#123;</div><div class="line">	return&#123;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;) ();</div></pre></td></tr></table></figure></p>
<p><strong>构造函数模式</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function Person()&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">var p = new Person();</div></pre></td></tr></table></figure></p>
<p><strong>什么叫做闭包</strong><br>函数执行形成一个私有的作用域=》闭包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function fn()&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">fn()</div></pre></td></tr></table></figure></p>
<p>闭包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">(function () &#123;</div><div class="line"></div><div class="line">&#125;) ();</div><div class="line">function fn()&#123;</div><div class="line">	return function()&#123;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">var f= fn();</div></pre></td></tr></table></figure></p>
<h3 id="6-原型模式"><a href="#6-原型模式" class="headerlink" title="6.原型模式"></a>6.原型模式</h3><p><strong>以下的几句话不要管为什么，因为他们是规定</strong></p>
<ul>
<li><p>每一个函数数据类型（普通函数、类（内置类、自定义类））都天生自带一个属性prototype,这个属性的属性值是一个对象数据类型的结果<code>Person.prototype=&gt;{ }</code></p>
</li>
<li><p>prototype对应的对象中，有一个天生自带的属性：constructor(构造函数)     这个属性的属性值指向的是当前函数本身 <code>Person.prototype=&gt;{constructor:Person}</code></p>
</li>
<li>每一个对象数据类型（普通对象、实例、prototype、函数也是对象）都有一个天生自带的属性：<code>_proto_</code>，这个属性指向自己所属类的原型(prototype)</li>
<li>类的原型（prototype）上存储的属性和方法都是实例公有的属性方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">function Person(name)&#123;</div><div class="line">//this.xxx=xxx都是实例的私有属性</div><div class="line">	this.name = name;</div><div class="line">	this.say = function ()&#123;</div><div class="line">		console.log(&apos;my name is&apos;+this.name);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">var p1 =new Person(&apos;韩晴晴&apos;);</div><div class="line">var p2 = new Person(&apos;赵薇&apos;);</div><div class="line"></div><div class="line"></div><div class="line">Person.prototype.drink=function()&#123;</div><div class="line">	console.log(&apos;cheers!&apos;)</div><div class="line"> &#125;</div><div class="line"> console.log(p1.say===p2.say);//false</div><div class="line"> console.log(p1.drink===p2.drink);//true</div><div class="line"> console.log(p1.hasOwnProperty(&apos;drink&apos;))//false</div><div class="line"> console.log(&apos;drink&apos; in p1);//true</div><div class="line"> p1.drink( );//cheers!</div><div class="line"> p1._proto_.drink(); //cheers!跳过了私有的查找，直接的找原型上的公有属性</div></pre></td></tr></table></figure>
<p><strong>原型链的机制<em>*</em></strong><br><code>p1.drink( );</code>//<br>先找自己私有的属性，如果私有的属性中没有drink，则继续到所属类的原型上查找。。一直找到Object.prototype为止=》这种查找的机制叫做<strong>原型链</strong></p>
<p><code>p1._proto_.drink( )</code>//跳过了私有的查找，直接的找原型上的公有属性<br><code>p1.hasOwnProperty()</code> this指向p1;<br><code>p1._proto_.hasOwnProperty()</code> this指向p1.<em>proto</em> (Person.prototype)<br><code>p1._proto_._proto_.hasOwnProperty()</code> this指向<code>p1._proto_.proto_(object.prototype)</code>=&gt;Object.prototype.hasOwnProperty( )=&gt;让Object原型上的hasOwnProperty方法执行</p>
<p><strong>通过以上三种方法，我们都可以把hasOwnProperty方法执行，但是有所区别：方法执行的时候，方法中的this是不一样的；在万恶的IE浏览器下，为了保护原型，屏蔽了我们使用<code>_proto_</code>这个属性</strong><br><img src="./6-原型模式.png" alt="Alt text"></p>
<h3 id="7-原型进阶"><a href="#7-原型进阶" class="headerlink" title="7.原型进阶"></a>7.原型进阶</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function Fn()&#123;</div><div class="line">	this.n = 100;</div><div class="line">&#125;</div><div class="line">Fn.prototype.m = 200;</div><div class="line">var f = new Fn();</div><div class="line">console.log(f.hasOwnProperty(&apos;n&apos;));//true</div></pre></td></tr></table></figure>
<p>//-&gt;在内置类的原型上扩展一个方法：如果这个方法之前人家有，我们这样操作会把之前的覆盖掉，这样非常不好，所以我们在取方法名的时候最好加一个特殊的前缀”my”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Object.prototype.myHasPublicProperty = function myHasPublicProperty()&#123;</div><div class="line">			//-&gt;this 需要处理的那个实例（对象）</div><div class="line">	var attr = arguments[0];</div><div class="line">	return (attr in this) &amp;&amp; !this.hasOwnProperty(attr);</div><div class="line">&#125;;</div><div class="line">console.log(f.myHasPublicProperty(&apos;m&apos;)); //true</div></pre></td></tr></table></figure></p>
<p>//-&gt;思考题：<br>数组中存在一个方法slice，在一个数组中进行查找，找到我们需要的部分，最后返回一个新数组，原来数组不变<br>ary.slice（）<br>ary.slice( n)<br>ary.slice(n,m)<br>如果n或者m或者两者都是负数<br>如果是小数呢<br>如果是非有效数字呢<br>如果传递的n&gt;m呢<br>如果传递的n或者m或者两者都大于最大长度呢<br>…</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Array.prototype.mySlice = function mySlice() &#123;</div><div class="line">        /*实现你的代码，完成和内置slice一模一样的功能：要求尽可能的考虑更多情况、不能使用数组中内置的方法*/</div><div class="line">        //return this.slice.apply(this, arguments); X</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="8-原型进阶-链式写法"><a href="#8-原型进阶-链式写法" class="headerlink" title="8.原型进阶-链式写法"></a>8.原型进阶-链式写法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var ary =[12, 23, 34, 11, 35, 24, 56];</div><div class="line">var newAry = ary.sort(function (a,b))&#123;</div><div class="line">	return a - b;</div><div class="line">&#125;</div><div class="line">console.log(ary); //会把原数组改变[11, 12, 23, 24, 34, 35, 56]</div><div class="line">console.log(newAry);//也有返回值，返回的结果时改变后的数组[11, 12, 23, 24, 34, 35, 56]</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var ary = [12, 23, 34, 11, 35, 24, 56];</div><div class="line">	var newAry = ary.sort(function (a,b)&#123;</div><div class="line">		return a-b;</div><div class="line">	&#125;);</div><div class="line">	newAry = newAry.slice（0，3);</div><div class="line">	console.log(newAry);   //[11,12,23]</div></pre></td></tr></table></figure>
<p>链式写法：需要保证每一次执行方法返回的结果依然是当前类的一个实例，这样就可以继续调取原型上的方法了…<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">ary.sort(function (a, b) &#123;</div><div class="line">       return a - b;</div><div class="line">   &#125;).slice(0, 3).reverse().push(100).pop();//-&gt;Uncaught TypeError: ary.sort(...).slice(...).reverse(...).push(...).pop is not a function 执行PUSH方法后，返回的结果是新增后数组的长度，是一个数字，不能在继续调取Array.prototype上的方法了</div><div class="line"></div><div class="line">   Array.prototype.mySlice = function mySlice() &#123;</div><div class="line"></div><div class="line">       return this;//-&gt;实现链式写法最简单的方式，就是在每一个方法执行完成后返回THIS即可，因为方法中的THIS就是当前类的实例</div><div class="line">   &#125;;</div><div class="line">   ary.mySlice().push();</div><div class="line"></div><div class="line"></div><div class="line">   /*思考题</div><div class="line">    *  (5).plus(3).minus(2)  =&gt;6  在Number的原型上扩展方法:plus和minus不仅可以实现加减操作而且还可以实现链式写法</div><div class="line">    */</div></pre></td></tr></table></figure></p>
<blockquote>
<p>Math不是类，它仅仅是一个对象，’Math’ in window=&gt;TRUE 它是window全局对象的一个属性而已，这个对象中包含了很多的方法，供我们操作数字，所以我们把它称之为“数学函数”</p>
</blockquote>
<p>Math.abs()<br>Math.ceil()<br>Math.floor()<br>Math.round()<br>Math.random()<br>Math.round(Math.random()*(m-n)+n)<br>Math.max()<br>Math.min()<br>Math.PI   3.141592653…<br>Math.pow(n,m) 获取n的m次幂 =&gt;Math.pow(5,3) -&gt;125<br>Math.sqrt(n) 给n开平方 =&gt;Math.sqrt(100) -&gt;10<br><img src="./JS类的构建体系图.png" alt="Alt text"></p>
<h3 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h3><ul>
<li>所有的函数数据类型（普通函数 类（自定义 内置）），都是Function这个类的实例</li>
<li>所有实例都是对象数据类型的，函数也是对象数据类型的</li>
<li>对象数据类型都有一个天生自带的属性<em>proto</em>指向所属类的原型</li>
<li>因为函数也是对象数据类型的 我们的Function（内置类）它也是函数数据类型，所以它也是对象数据类型的 每一个对象数据类型都有一个天生自带的属性<em>proto</em>,</li>
<li>Function是一个内置类，类都是函数数据类型 所有函数数据类型都是Function这个内置类的实例；所以Function作为一个类一个对象数据类型，它的<em>proto</em>指向所属类的原型Function的prototype也就是Function自己的prototype</li>
<li>object是一个基类，js中最顶层的类，类都是函数数据类型 函数也是对象数据类型 那么object也有一个天生自带的属性<em>proto</em>,因为object也是函数数据类型的，它的—proto—指向的Function的prototype</li>
</ul>
<h3 id="重构对象原型"><a href="#重构对象原型" class="headerlink" title="重构对象原型"></a>重构对象原型</h3><p>每个类天生自带的属性 浏览器为它开辟了一个堆内存 里面有一个天生自带的属性constructor，constructor指当前函数（类）的本身</p>
<p>重构原型对象 自己开辟的堆内存 来存储公有的属性和方法 将浏览器天生为Fn.prototype开辟的堆内存替换掉</p>
<p>f1.constructor 由于我们为Fn.prototype新开辟了一个堆内存，所以最终通过原型链查找，找到的是Object.prototype上constructor =&gt;object</p>
<p>只有浏览器天生为Fn.prototype开辟的堆内存才有constructor这个属性，我们自己开辟的堆内存没有constructor没有这个属性prototype开辟的堆内存里添加constructor指向Fn</p>
<p>我们为了和原来一样就自己手动在 自己为Fn.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Fn.prototype = &#123;</div><div class="line">        constructor: Fn,</div><div class="line">        y: 10</div><div class="line">    &#125;;</div><div class="line">    var f1 = new Fn;</div><div class="line">    console.log(Fn.prototype);</div><div class="line">    console.log(f1.constructor)</div></pre></td></tr></table></figure>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2017/07/07/3.JS3/">
    <time datetime="2017-07-07T03:59:46.511Z" class="entry-date">
        2017-07-07
    </time>
</a>
    
    
    </footer>
</article>


    
<nav class="nav-single">
    <h3 class="assistive-text">文章导航</h3>
    
        <span class="nav-previous"><a href="/2017/07/07/6.js改变this/" rel="prev"><span class="meta-nav">←</span> JavaScript基础总结6</a></span>
    
    
        <span class="nav-next"><a href="/2017/07/07/2.JS2/" rel="next">JavaScript基础总结2 <span class="meta-nav">→</span></a></span>
    
</nav><!-- .nav-single -->







</div></div>
        <div id="secondary" class="widget-area" role="complementary">
  
    <aside id="search" class="widget widget_search"><form role="search" method="get" accept-charset="utf-8" id="searchform" class="searchform" action="//google.com/search">
    <div>
        <input type="text" value="" name="s" id="s" />
        <input type="submit" id="searchsubmit" value="搜索" />
    </div>
</form></aside>
  
    
  
    
  
    
  <aside class="widget">
    <h3 class="widget-title">Recents</h3>
    <div class="widget-content">
      <ul>
        
          <li>
            <a href="/2017/07/08/mobile3/">移动端总结-3</a>
          </li>
        
          <li>
            <a href="/2017/07/08/HTML5+CSS3/11/">11.html5+css3</a>
          </li>
        
          <li>
            <a href="/2017/07/08/HTML5+CSS3/10/">10.html5+css3</a>
          </li>
        
          <li>
            <a href="/2017/07/08/HTML5+CSS3/9/">9.html5+css3</a>
          </li>
        
          <li>
            <a href="/2017/07/08/HTML5+CSS3/8/">8.html5+css3</a>
          </li>
        
      </ul>
    </div>
  </aside>

  
    
  
    
  
</div>
      </div>
      <footer id="colophon" role="contentinfo">
    <p>&copy; 2017 John Doe
    All rights reserved.</p>
    <p>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></p>
</footer>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"1","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"16"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>

<script src="/js/jquery-2.0.3.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

<script src="/js/navigation.js"></script>

<div id="bg"></div>

  </div>
</body>
</html>