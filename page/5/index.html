<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  

  
  
  
  
  
  
  <title>我的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="我的博客">
<meta property="og:url" content="http://yoursite.com/page/5/index.html">
<meta property="og:site_name" content="我的博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="我的博客">
  
  
    <link rel="icon" href="/css/images/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  

  
  <!-- baidu webmaster push -->
  <script src='//push.zhanzhang.baidu.com/push.js'></script>
</head>
<body class="home blog custom-background custom-font-enabled single-author">
  <div id="page" class="hfeed site">
      <header id="masthead" class="site-header" role="banner">
    <hgroup>
      <h1 class="site-title">
        <a href="/" title="我的博客" rel="home">我的博客</a>
      </h1>
      
        <script type="text/javascript" src="http://api.hitokoto.us/rand?encode=js&charset=utf-8"></script>
        <h2 class="site-description"><script>hitokoto();</script></h2>
      
    </hgroup>

    <nav id="site-navigation" class="main-navigation" role="navigation">
            <button class="menu-toggle">菜单</button>
            <a class="assistive-text" href="/#content" title="跳至内容">跳至内容</a><!--TODO-->
            <div class="menu-main-container">
                <ul id="menu-main" class="nav-menu">
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/">Home</a></li>
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/archives">Archives</a></li>
                
                </ul>
            </div>
    </nav>
</header>
      <div id="main" class="wrapper">
        <div id="primary" class="site-content"><div id="content" role="main">
  
    <article id="post-12.简单动画" class="post-12.简单动画 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2017/07/08/12.简单动画/">JavaScript基础总结12</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2017/07/08/12.简单动画/" data-id="cj4v4j65y0002t8w97ohvfk6v" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h1 id="16、简单动画"><a href="#16、简单动画" class="headerlink" title="16、简单动画"></a>16、简单动画</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">匀速运动公式：当前时间，初始偏移值，总运动量，总运动时间</div><div class="line">function(time,begin,change,duration)&#123;</div><div class="line">           return   time/duration*change+begin;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2017/07/08/12.简单动画/">
    <time datetime="2017-07-08T06:13:35.102Z" class="entry-date">
        2017-07-08
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-11.JS中兼容性检测" class="post-11.JS中兼容性检测 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2017/07/08/11.JS中兼容性检测/">JavaScript基础总结11</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2017/07/08/11.JS中兼容性检测/" data-id="cj4v4j64m0000t8w9ijerez2v" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h1 id="15、JS中兼容性检测"><a href="#15、JS中兼容性检测" class="headerlink" title="15、JS中兼容性检测"></a>15、JS中兼容性检测</h1><h2 id="getElementByTagName-它的筛选范围是当前上下文的后代元素（子子孙孙）"><a href="#getElementByTagName-它的筛选范围是当前上下文的后代元素（子子孙孙）" class="headerlink" title="getElementByTagName: 它的筛选范围是当前上下文的后代元素（子子孙孙）"></a>getElementByTagName: 它的筛选范围是当前上下文的后代元素（子子孙孙）</h2><h2 id="children-：获取所有元素子节点，但是在IE低版本浏览器中和标准浏览器中获取的结果不统一，IE低版本浏览器会把注释节点也当做元素节点获取到（需要处理兼容）"><a href="#children-：获取所有元素子节点，但是在IE低版本浏览器中和标准浏览器中获取的结果不统一，IE低版本浏览器会把注释节点也当做元素节点获取到（需要处理兼容）" class="headerlink" title="children ：获取所有元素子节点，但是在IE低版本浏览器中和标准浏览器中获取的结果不统一，IE低版本浏览器会把注释节点也当做元素节点获取到（需要处理兼容）"></a>children ：获取所有元素子节点，但是在IE低版本浏览器中和标准浏览器中获取的结果不统一，IE低版本浏览器会把注释节点也当做元素节点获取到（需要处理兼容）</h2><p>jQ中常用的三个筛选的方法:children (子代查找) 、find（后代查找）、filter（同级过滤）===尝试基于children的方法思考</p>
<h3 id="JS中兼容性检测的三大方式："><a href="#JS中兼容性检测的三大方式：" class="headerlink" title="JS中兼容性检测的三大方式："></a>JS中兼容性检测的三大方式：</h3><h4 id="1、try-catch-异常捕获"><a href="#1、try-catch-异常捕获" class="headerlink" title="1、try  catch  异常捕获"></a>1、try  catch  异常捕获</h4><ul>
<li>原理：把我们执行的代码放在try中 尝试执行  如果没报错说明兼容，报错说明不兼容，但是报错会执行catch中的代码，我们在catch中处理兼容即可</li>
<li>前提：代码在不兼容的浏览器中执行会报错，我们才能使用这种方法</li>
<li>弊端： 不管当前浏览器是否支持，都需要把try 中的代码先执行一次，这样对性能和浏览器不友好，  所以一般很少用</li>
</ul>
<h4 id="2、检测浏览器的类型和版本号"><a href="#2、检测浏览器的类型和版本号" class="headerlink" title="2、检测浏览器的类型和版本号"></a>2、检测浏览器的类型和版本号</h4><ul>
<li>原理：只要我们知道当前操作不兼容什么样的浏览器（前提），我们可以先获取当前浏览器的版本号，验证一下是否在不兼容的清单中， 通过这样的判断来检测兼容即可<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">window.navigator.userAgent---&gt;获取当前浏览器的版本信息</div><div class="line">如果是IE包括“MSIE 版本号” 这样的字符串</div><div class="line">思考题：回去查询JS检测浏览器的代码，分析各个浏览器版本信息的规律</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3、检测当前的方法或者属性是否属于某个对象，属于就兼容，不属于就不兼容"><a href="#3、检测当前的方法或者属性是否属于某个对象，属于就兼容，不属于就不兼容" class="headerlink" title="3、检测当前的方法或者属性是否属于某个对象，属于就兼容，不属于就不兼容"></a>3、检测当前的方法或者属性是否属于某个对象，属于就兼容，不属于就不兼容</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">第一种写法</div><div class="line">if(&apos;getComputedStyle&apos; in window)&#123; &#125;</div><div class="line"></div><div class="line">第二种写法</div><div class="line">if(window.getComputedStyle)&#123; //获取属性值  看是否属于undefined  属于的话条件就不成立了，反之条件成立</div><div class="line">&#125;</div><div class="line"></div><div class="line">第三种写法</div><div class="line">if(typeof window.getComputedStyle!==&apos;undefined&apos;)&#123;  &#125;</div></pre></td></tr></table></figure>
<h2 id="JS高阶编程技巧：惰性思想"><a href="#JS高阶编程技巧：惰性思想" class="headerlink" title="JS高阶编程技巧：惰性思想"></a>JS高阶编程技巧：惰性思想</h2><p>能够执行一次就解决的，我们绝不会执行多次<br>第一次给utils赋值的时候，执行自执行函数，形成一个不销毁的私有作用域，我们在这里就把是否兼容处理好了，存在一个私有变量中，以后再需要检测是否兼容，我们直接的使用变量即可，没必要重复的操作检测；</p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2017/07/08/11.JS中兼容性检测/">
    <time datetime="2017-07-08T06:11:04.279Z" class="entry-date">
        2017-07-08
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-10.JS盒子模型和继承" class="post-10.JS盒子模型和继承 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2017/07/08/10.JS盒子模型和继承/">JavaScript基础总结10</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2017/07/08/10.JS盒子模型和继承/" data-id="cj4v4j65q0001t8w9xd3n01wd" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h1 id="14、JS盒子模型和继承"><a href="#14、JS盒子模型和继承" class="headerlink" title="14、JS盒子模型和继承"></a>14、JS盒子模型和继承</h1><h2 id="JS盒子模型中的常用属性"><a href="#JS盒子模型中的常用属性" class="headerlink" title="JS盒子模型中的常用属性"></a>JS盒子模型中的常用属性</h2><p>client（width/height/top/left/）<br>offset(width/height/top/left) offsetParent<br>scroll(width/height/top(读写)/left（读写）)<br>//其他的属性只能读<br>ofset:获取当前元素相对于BODY的偏移（top：xxx,left:xxx)</p>
<h2 id="获取当前元素具体的某一个样式值："><a href="#获取当前元素具体的某一个样式值：" class="headerlink" title="获取当前元素具体的某一个样式值："></a>获取当前元素具体的某一个样式值：</h2><p>curEle.style.xxx  :  只能获取写在元素行内上的样式<br>getComputedStyle  /  currentStyle: 获取当前元素所有经过浏览器计算的样式<br>—-getCss<br>—-setCss<br>—-setGroupCss（批量设置）<br>——-&gt;  JQ中的css方法</p>
<p>在IE低版本浏览器下 不支持opacity</p>
<h2 id="setCss-设置元素某一个样式的值（原理：设置当前元素的行内样式）"><a href="#setCss-设置元素某一个样式的值（原理：设置当前元素的行内样式）" class="headerlink" title="setCss:设置元素某一个样式的值（原理：设置当前元素的行内样式）"></a>setCss:设置元素某一个样式的值（原理：设置当前元素的行内样式）</h2><p>当传递的实参不符合规范的时候 我们进行容错处理 或者给予相关的默认值<br>throw new Error ( ‘ ‘ )  :异常抛出<br>SyntaxRrror (语法错误 )<br>TypeError (类型错误)<br>RangeError(超出范围)<br>ReferenceError(引用错误)</p>
<p>1、对于某些样式属性，如果传递的参数值没有加单位  我们可以自动给补充单位（px）  但是 不是所有的都需要补充，例如：border、float、z-Index 、opacity。。。。margin不补，但是可以给marginleft补充单位</p>
<h2 id="setGroupCss-批量设置"><a href="#setGroupCss-批量设置" class="headerlink" title="setGroupCss(批量设置)"></a>setGroupCss(批量设置)</h2><p>options: 当前要设置IDE样式属性集合（对象）<br>原理：获取传递的属性集合，然后进行遍历循环，调取SET CSS方法依次设置即可</p>
<blockquote>
<p>/(\d)’+strClass+’/  —&gt;使用字面量方式创建的正则，在两个斜杠之间包含起来的都是元字符  没有字符串拼接或者变量一说<br>把 strClass变量存储的值作为正则的一部分 ，这种情况下只能使用实例创建的方式new RegExp(‘[元字符部分]’,[修饰符])<br>小技巧：使用实例创建方式创建的正则，当遇到 \xxx     情况，我们都需要在\之前</p>
</blockquote>
<h2 id="可枚举和不可枚举"><a href="#可枚举和不可枚举" class="headerlink" title="可枚举和不可枚举"></a>可枚举和不可枚举</h2><p>枚举是一一列举出来<br>可以for in  语句遍历列举出来的</p>
<p>预防将原型上可枚举的其他属性遍历出来  遍历对象时，通常会用hasOwnProperty</p>
<h2 id="propertyIsEnumerable-检测属性是不是当前对象可枚举的自身属性-如果是当前对象可枚举的自身属性返回true"><a href="#propertyIsEnumerable-检测属性是不是当前对象可枚举的自身属性-如果是当前对象可枚举的自身属性返回true" class="headerlink" title="propertyIsEnumerable  检测属性是不是当前对象可枚举的自身属性  如果是当前对象可枚举的自身属性返回true"></a>propertyIsEnumerable  检测属性是不是当前对象可枚举的自身属性  如果是当前对象可枚举的自身属性返回true</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Object.create  返回一个新对象obj2</div><div class="line">obj2.__proto__=obj1（被截胡了）</div><div class="line">var obj1=&#123;name:&apos;zhufeng&apos;&#125;;</div><div class="line">var obj2=Objecr.create(obj1);</div><div class="line">//但是这个方法在IE8 以下不兼容</div><div class="line"></div><div class="line"></div><div class="line">自己创建一个方法</div><div class="line">function objectCreate(obj)&#123;</div><div class="line">     function Fn()&#123;&#125;;</div><div class="line">     Fn.prototype=obj;</div><div class="line">     return new Fn(); //new Fn 这个实例的__proto__=Fn.prototype=obj</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="继承：子类继承父类的属性和方法"><a href="#继承：子类继承父类的属性和方法" class="headerlink" title="继承：子类继承父类的属性和方法"></a>继承：子类继承父类的属性和方法</h1><p>比如：A类 B类  在A类中有一个say方法  B类想继承过来给B的实例使用</p>
<h2 id="1、原型继承（原型链继承）"><a href="#1、原型继承（原型链继承）" class="headerlink" title="1、原型继承（原型链继承）"></a>1、原型继承（原型链继承）</h2><h4 id="原型继承-子类B把A中的公有、私有属性和方法-全部继承过来-作为子类的B的公有属性和方法"><a href="#原型继承-子类B把A中的公有、私有属性和方法-全部继承过来-作为子类的B的公有属性和方法" class="headerlink" title="原型继承  子类B把A中的公有、私有属性和方法 全部继承过来  作为子类的B的公有属性和方法"></a>原型继承  子类B把A中的公有、私有属性和方法 全部继承过来  作为子类的B的公有属性和方法</h4><p> 修改原型链的查找顺序<br>  比如 A类和B类  在A类中有一个say方法，B类想继承过来给B的实例使用<br> <strong> B.prototype=new A( );</strong></p>
<ul>
<li>原型继承中 子类不光可以继承父类的属性和方法来使用</li>
<li>子类也可以修改父类的原型上的属性和方法</li>
<li>但是会影响父类的其他实例-<br>   —-&gt;子类重写父类   属于类的多态（重写）<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function A() &#123;</div><div class="line">     this.name1 = &apos;zhufeng&apos;;</div><div class="line">     this.info = function () &#123;</div><div class="line">       console.log(&apos;info&apos;);</div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line">   A.prototype.say = function () &#123;</div><div class="line">       console.log(&apos;my name is &apos; + this.name1);</div><div class="line">   &#125;;</div><div class="line">   B.prototype = new A();// B类的原型等于A类的实例</div><div class="line">   function B() &#123;</div><div class="line"></div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="2、call继承（借用构造函数）"><a href="#2、call继承（借用构造函数）" class="headerlink" title="2、call继承（借用构造函数）"></a>2、call继承（借用构造函数）</h2><h4 id="call继承只能父类中私有的属性"><a href="#call继承只能父类中私有的属性" class="headerlink" title="call继承只能父类中私有的属性"></a>call继承只能父类中私有的属性</h4><ul>
<li>call（借用构造函数）继承  让A类当做一个普通函数在B类中执行 并且将A类中的this.改为B类的实例</li>
<li>那么A类中this.xxx=xxx 就相当于给B类的实例添加私有属性</li>
<li>call继承  将A类中的私有属性  复制一份  给B类作为私有属性</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function A() &#123;</div><div class="line">       this.name = &apos;nameA&apos;; // 在B中A.call(this); A中this被改为B的实例</div><div class="line">   &#125;</div><div class="line">   A.prototype.say = function () &#123;</div><div class="line">     console.log(&apos;say&apos;);</div><div class="line">   &#125;</div><div class="line">   function B() &#123; // B作为类 的时候 B中this 是当前实例</div><div class="line">       A.call(this); // 让A在B的函数体中当做一个普通函数执行并且将A中this改为B的this(B的实例把b)</div><div class="line">   &#125;</div><div class="line">   var b = new B();</div><div class="line">   console.log(b);</div><div class="line">   console.log(b.name);</div><div class="line">   // call继承只能继承父类中的私有属性</div></pre></td></tr></table></figure>
<h2 id="3、混合模式继承-（call继承-原型继承）"><a href="#3、混合模式继承-（call继承-原型继承）" class="headerlink" title="3、混合模式继承 （call继承+原型继承）"></a>3、混合模式继承 （call继承+原型继承）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function A() &#123;</div><div class="line">       this.name = &apos;nameA&apos;;</div><div class="line">     &#125;</div><div class="line">     A.prototype.say = function () &#123;</div><div class="line">       console.log(&apos;hello world!&apos;);</div><div class="line">     &#125;;</div><div class="line">     function B() &#123;</div><div class="line">        A.call(this); // call继承 只能继承父类中私有属性</div><div class="line">     &#125;</div><div class="line">     B.prototype = new A(); // 原型继承 父类公有和私有都继承</div><div class="line">     var b = new B();</div><div class="line">     console.log(b.name); // 继承过来的私有属性</div><div class="line">     b.say();</div></pre></td></tr></table></figure>
<h3 id="4、寄生组合模式继承（各司其职）"><a href="#4、寄生组合模式继承（各司其职）" class="headerlink" title="4、寄生组合模式继承（各司其职）"></a>4、寄生组合模式继承（各司其职）</h3><p>function bg(o){<br> function Fn( ) { };<br> Fn.prototype=o;<br> return new Fn( );<br>}</p>
<h3 id="5、-冒充对象继承-在b-的私有函数体中，创建一个父类的实例temp-（存储的是a类中私有和公有的属性和方法），把temp存储的-复制一份-给B中实例的私有属性"><a href="#5、-冒充对象继承-在b-的私有函数体中，创建一个父类的实例temp-（存储的是a类中私有和公有的属性和方法），把temp存储的-复制一份-给B中实例的私有属性" class="headerlink" title="5、 冒充对象继承(在b 的私有函数体中，创建一个父类的实例temp （存储的是a类中私有和公有的属性和方法），把temp存储的 复制一份  给B中实例的私有属性)"></a>5、 冒充对象继承(在b 的私有函数体中，创建一个父类的实例temp （存储的是a类中私有和公有的属性和方法），把temp存储的 复制一份  给B中实例的私有属性)</h3><p>冒充对象继承   在子类的私有函数体中  创建一个父类A的实例temp（存储的是A类中的私有和公有的属性和方法），吧temp当做一个普通对象循环遍历出来没一项 作为子类中的实例的私有属性</p>
<ul>
<li>在子类的函数体中 创建一个父类的实例temp</li>
<li>吧temp当作一个普通对象遍历</li>
<li>将temp存储的公有和私有属性和方法 复制一份给子类中的私有属性</li>
</ul>
<p>function B(){<br>  var temp=new A( )<br>  for (var key in temp){<br>      console.log(key);<br>  }<br>}</p>
<h3 id="6、中间类继承"><a href="#6、中间类继承" class="headerlink" title="6、中间类继承"></a>6、中间类继承</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">// 中间类继承：通过使用__proto__</div><div class="line">     // var arr = [1,2,4]; // arr.__proto__.shift</div><div class="line">     // arr.shift();</div><div class="line">     // console.log(arr);</div><div class="line">     // console.log(arr.__proto__.shift === Array.prototype.shift);</div><div class="line">     // console.log(arr.__proto__ === Array.prototype);</div><div class="line">     // function add() &#123;</div><div class="line">     //   // 类数组的__proto__ 指向了 Array.prototype</div><div class="line">     //   arguments.__proto__ =  Array.prototype;</div><div class="line">     //   arguments.shift(); // [2,3,4,5]</div><div class="line">     //   console.log(arguments);</div><div class="line">     // &#125;</div><div class="line">     // add(1,2,3,4,5)</div><div class="line">     console.log([].__proto__);</div><div class="line">     function sorts() &#123;</div><div class="line">       arguments.__proto__ =  Array.prototype;</div><div class="line">       arguments.sort();</div><div class="line">       console.log(arguments);</div><div class="line">     &#125;</div><div class="line">     sorts(6,9,3,5,8);</div></pre></td></tr></table></figure>
      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2017/07/08/10.JS盒子模型和继承/">
    <time datetime="2017-07-08T06:07:57.434Z" class="entry-date">
        2017-07-08
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-9.JS类名的增删改查" class="post-9.JS类名的增删改查 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2017/07/08/9.JS类名的增删改查/">JavaScript基础总结9</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2017/07/08/9.JS类名的增删改查/" data-id="cj4v4j6cg0010t8w98qt59ewk" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h1 id="13、类名的增删改查"><a href="#13、类名的增删改查" class="headerlink" title="13、类名的增删改查"></a>13、类名的增删改查</h1><h2 id="字面量方式-无法在正则中拼接变量"><a href="#字面量方式-无法在正则中拼接变量" class="headerlink" title="字面量方式 无法在正则中拼接变量"></a>字面量方式 无法在正则中拼接变量</h2><p>new RegExp 可以拼接变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p>
<h2 id="类名的增删改查"><a href="#类名的增删改查" class="headerlink" title="类名的增删改查"></a>类名的增删改查</h2><p>oDiv.classList.remove(‘c1’)  移出类<br>oDiv.classList.add(‘c2’)   增加类<br>oDiv.classList.toggle(‘c4’)  切换类 （当前元素中  有就移除  没有就添加</p>
<blockquote>
<p>查看当前元素存不存在指定class<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function hasClass(ele,cName)&#123;</div><div class="line">    return (new RegExp(&apos;(^| )&apos;+cName+&apos;( |$)&apos;)).test(ele.className)</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
</blockquote>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2017/07/08/9.JS类名的增删改查/">
    <time datetime="2017-07-08T06:05:51.598Z" class="entry-date">
        2017-07-08
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-8.JS获取元素样式属性" class="post-8.JS获取元素样式属性 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2017/07/08/8.JS获取元素样式属性/">JavaScript基础总结8</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2017/07/08/8.JS获取元素样式属性/" data-id="cj4v4j6bs000yt8w905wcbhou" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h1 id="12、获取元素样式属性"><a href="#12、获取元素样式属性" class="headerlink" title="12、获取元素样式属性"></a>12、获取元素样式属性</h1><p>复习：<br>clientWidth<br>clientHeight<br>clientLeft<br>clientTop</p>
<p>元素.style只能获取到行内样式</p>
<p>window.getComputedStyle 通过它获取所有经过浏览器计算过的元素样式属性和属性值（元素在浏览器加载的时候渲染出来 展现在页面中的样式）<br>window.getComputedStyle(元素，伪类【通常不写， 用null占位】) <code>但是IE8以下不兼容----只能使用currentStyle</code><br>元素.currentStyle[attr]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">获取元素样式</div><div class="line">function getCss(ele,attr)&#123;</div><div class="line">var val;</div><div class="line">   if(&quot;getComputedStyle&quot; in window)&#123;</div><div class="line">   val=window.getComputStyle(ele,null)[attr]</div><div class="line">   &#125;</div><div class="line">   else if(attr===&apos;opacrty&apos;)&#123;</div><div class="line">     val=ele.currentStyle.filer;</div><div class="line">     var reg=/^alpha\(opacity=(\d+(?:\.\d+)?)\)$/;</div><div class="line">     val=reg.test(val)?(reg.exec(val)[1])/100:1;</div><div class="line">   &#125;</div><div class="line">   else&#123;</div><div class="line">      val=ele.currentStyle[attr];</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line">     var regs=/^-?\d+(\.\d)?(px|pt|rem|em)?$/;</div><div class="line">     return regs.test(val)?parseFloat(val):val;</div></pre></td></tr></table></figure>
<p>加单位  如果不带单位的value  我们给加上单位</p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2017/07/08/8.JS获取元素样式属性/">
    <time datetime="2017-07-08T06:03:33.007Z" class="entry-date">
        2017-07-08
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-7.JS盒子模型" class="post-7.JS盒子模型 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2017/07/07/7.JS盒子模型/">JavaScript基础总结7</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2017/07/07/7.JS盒子模型/" data-id="cj4v4j6d20016t8w94mi5r3rq" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h1 id="11、盒子模型"><a href="#11、盒子模型" class="headerlink" title="11、盒子模型"></a>11、盒子模型</h1><p>检测字母出现的次数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">var str=&apos;my name is zhou xiao tian&apos;</div><div class="line">var reg=/(?!\s)[a-z]/g;</div><div class="line">var obj=&#123;&#125;;</div><div class="line">str.replace(reg,function()&#123;</div><div class="line">     var cur=arguments[0];</div><div class="line">     if(obj[cur])&#123;</div><div class="line">      obj[cur]++;</div><div class="line">     &#125;else&#123;</div><div class="line">     obj[cur]=1;</div><div class="line">     &#125;</div><div class="line">&#125;)</div><div class="line">console.log(obj);</div><div class="line"></div><div class="line"></div><div class="line"> 比较那个出现的次数最多</div><div class="line">var max=obj[&apos;m&apos;];</div><div class="line">for(var key in obj)&#123;</div><div class="line">var cur=obj[key];</div><div class="line">  cur&gt;max ? max=cur:null;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">得到出现次数最多的那一项</div><div class="line">var ary=[];</div><div class="line">for(var key in obj)&#123;</div><div class="line">   if(obj[key]==max)&#123;</div><div class="line">   ary.push(key)</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var str=&apos;http://www.baidu.com/index.html?name=狮子王&amp;age=20&amp;sex=1&apos;</div><div class="line"></div><div class="line">//封装一个方法</div><div class="line">function getParamer()&#123;</div><div class="line">var reg=/([^?&amp;=]+)=([^?&amp;=]+)/g;</div><div class="line">var obj=[];</div><div class="line">url.replace(reg,function()&#123;</div><div class="line">   obj[arguments[1]]=arguments[2];</div><div class="line">&#125;)</div><div class="line">&#125;</div><div class="line">console.log(getParamer(obj))</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">var time=&apos;2017-3-25 18:00:56&apos;</div><div class="line">方式一</div><div class="line">var times=time.split(/[- :]/);</div><div class="line"></div><div class="line">方式二</div><div class="line">time.replace(/(\d+)-(\d+)-(\d+) (\d+):(\d+):(\d+)/g,&apos;$1年$2月$3日 $4时$5分$6秒&apos;);</div><div class="line">&#125;)</div><div class="line">console.log(times);</div><div class="line">方式三</div><div class="line"> var time = &apos;2017-3-26 18:38:4&apos;;</div><div class="line">        var reg = /(\d+)/g;</div><div class="line">        var count = 0;</div><div class="line">        var arr = [&apos;年&apos;,&apos;月&apos;,&apos;日 &apos;,&apos;时&apos;,&apos;分&apos;,&apos;秒&apos;];</div><div class="line">        var str = &apos;&apos;;</div><div class="line">        var timer = time.replace(reg, function (a) &#123;</div><div class="line">              str += addZero(a) + &apos;&apos;+ arr[count++];</div><div class="line">        &#125;);</div><div class="line">      console.log(str);</div></pre></td></tr></table></figure>
<p> 去除字符串的首尾空格<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var str=&apos;  may name is zccc  &apos;  //</div><div class="line">var reg=/^\s+|\s+$/;</div><div class="line">或者var reg=/^ +| +$/;</div><div class="line">str.replace(reg,&apos;&apos;);</div></pre></td></tr></table></figure></p>
<p>千分符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var str3=&apos;1324935048334543&apos;</div><div class="line">var reg=/\d(?=(?:\d&#123;3&#125;)+(?:\.\d+|$))/g</div><div class="line">str.replace(reg,$0+&apos;,&apos;);</div></pre></td></tr></table></figure></p>
<p>//输入框非空验证<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">&lt;body&gt;</div><div class="line">用户名：&lt;input type=&quot;text&quot; id=&quot;inp&quot;&gt;</div><div class="line">&lt;p id=&quot;info&quot;&gt;请填写用户名&lt;/p&gt;</div><div class="line">&lt;h3 id=&quot;text&quot;&gt;&lt;/h3&gt;</div><div class="line">&lt;script&gt;</div><div class="line">var inp=document.getElementById(&apos;inp&apos;);</div><div class="line">var info=document.getElementById(&apos;info&apos;);</div><div class="line">var text=document.getElementById(&apos;text&apos;);</div><div class="line">inp.onblur=validVal;</div><div class="line">//失去焦点的时候检测输入内容是否为空</div><div class="line">inp.oninput=validVal;</div><div class="line">//实时输入的时候检测输入内容是否为空</div><div class="line">function validVal()&#123;</div><div class="line">text.innerHTML=this.value;</div><div class="line">var reg=/^\s*$/;</div><div class="line">if(reg.test(this.value))&#123;</div><div class="line">    info.style.display=&apos;block&apos;;</div><div class="line">&#125;else&#123;</div><div class="line">    info.style.display=&apos;none&apos;;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<h1 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h1><h3 id="client"><a href="#client" class="headerlink" title="client"></a>client</h3><blockquote>
<p>clientWidth  内容宽度+左右padding<br>clientHeight  内容高度+上下padding<br>clientLeft   左边框的宽度<br>clientTop   上边框的宽度</p>
</blockquote>
<h3 id="offset"><a href="#offset" class="headerlink" title="offset"></a>offset</h3><blockquote>
<p>offsetWidth    clientWidth+左右边框的宽度<br>offsetHeight   clientHeight+上下边框的宽度</p>
<h3 id="偏移值"><a href="#偏移值" class="headerlink" title="偏移值"></a>偏移值</h3><p>offsetLeft  元素左边框外  距离父级参照物（默认是body）的左偏移量<br>offsetTop  元素上边框  距离父级参照物（默认是body）的上偏移量</p>
</blockquote>
<p>offsetParent  元素父级参照物    parentNode（父级节点）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">offsetParent  元素父级参照物是可以修改的 想让谁是父级参照物，就是谁给加上position（relative/absolute/fixed)</div><div class="line"></div><div class="line">在IE7以下父级参照物是当前元素上级父节点</div><div class="line"></div><div class="line">我们比较常用的是获取 当前元素距离body的上偏移和下偏移</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function offset(ele)&#123;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>###scroll</p>
<blockquote>
<p>scrollWidth<br>scrollHeight<br>在没有溢出的情况下<br>scrollWidth    等于     clientWidth<br>scrollHeight   等于   clientHeight</p>
<blockquote>
<p>在有溢出的情况下<br>scrollWidth    等于     clientWidth(一屏可视窗口的宽度)+左右溢出的内容部分<br>scrollHeight   等于   clientHeight(一屏可视窗口的高度)+ 上下溢出的内容部分<br>scrollLeft  （可设置值）左右滚动条  可滚动的区域<br>scrollTop  （可设置值）上下滚动条  可滚动的区域</p>
</blockquote>
</blockquote>
<p>###封装一个获取文档的一些盒模型样式属性值的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function win(attr,val)&#123;</div><div class="line">    if(typeof val===&apos;undefined&apos;)&#123;</div><div class="line">    return   document.documentElement[attr]||document.body[attr];</div><div class="line">  &#125;</div><div class="line">document.documentElement[attr]=val;</div><div class="line">document.body[attr]=val;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<p>##JS中提供获取元素的样式属性值</p>
<blockquote>
<p>获取元素的某一个具体的样式属性值<br>元素.style.属性名<br>—需要我们把元素的样式都写在行内上才可以（写在样式表中不起作用）<br>在真实项目中 ，这种方式不常用，因为我不能为了获取值而把所有的样式都写在行内（无法实现css和html的分离)</p>
</blockquote>
<p>###为了解决这个问题  我们可以使用<strong>window.getComputedStyle</strong>这个方法获取所有经过浏览器计算过的样式</p>
<p>###window.getComputedStyle(当前要操作的元素对象 ，当前元素的伪类（一般我们不用为了写null）)</p>
<h3 id="在IE6–8下我们可以使用currentStyle来获取所有经过浏览器计算过的样式"><a href="#在IE6–8下我们可以使用currentStyle来获取所有经过浏览器计算过的样式" class="headerlink" title="在IE6–8下我们可以使用currentStyle来获取所有经过浏览器计算过的样式"></a>在IE6–8下我们可以使用currentStyle来获取所有经过浏览器计算过的样式</h3><p>##通过检测浏览器版本和类型来处理兼容常用的三种方法<br>方法1、使用try catch方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">function get(curEle,attr)&#123;</div><div class="line">var val=null；</div><div class="line">   try&#123;</div><div class="line">val=window.getComputedStyle(curEle,null)</div><div class="line">&#125;  catch(e)&#123;</div><div class="line">val=curEle.currentStyle[attr];</div><div class="line">&#125;</div><div class="line">return val;</div><div class="line">&#125;</div><div class="line">console.log(getCss(box,&quot;height&quot;));</div></pre></td></tr></table></figure></p>
<p>方法2、 使用in方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">原理：（判断当前浏览器是否存在这个属性或者方法，存在就兼容，不存在就不兼容）</div><div class="line">function get(curEle,attr)&#123;</div><div class="line">var val=null；</div><div class="line"> if(&apos;getComputedStyle&apos; in window//(或者window.getComputedStyle)</div><div class="line"> )&#123;</div><div class="line">      val=window.getComputedStyle(curEle,null)[attr];</div><div class="line"> &#125;else&#123;</div><div class="line">      val=curEle.currentStyle[attr];</div><div class="line"> &#125;</div><div class="line"> return val;</div><div class="line">&#125;</div><div class="line">console.log(getCss(box,&quot;height&quot;));</div></pre></td></tr></table></figure></p>
<p>方法3 、通过检测浏览器版本和类型来处理兼容</p>
<blockquote>
<p>我们用window.navigator.userAgent<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">function get(curEle,attr)&#123;</div><div class="line">var val=null；</div><div class="line"> if(/MSIE (6|7|8)/.test(navigator.userAgent))</div><div class="line"> )&#123;</div><div class="line">     val=curEle.currentStyle[attr];</div><div class="line"> &#125;else&#123;</div><div class="line">  val=window.getComputedStyle(curEle,null)[attr];</div><div class="line"></div><div class="line"> &#125;</div><div class="line"> return val;</div><div class="line">&#125;</div><div class="line">console.log(getCss(box,&quot;height&quot;));</div></pre></td></tr></table></figure></p>
</blockquote>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2017/07/07/7.JS盒子模型/">
    <time datetime="2017-07-07T04:51:51.825Z" class="entry-date">
        2017-07-07
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-5.JS RegExp" class="post-5.JS RegExp post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2017/07/07/5.JS RegExp/">JavaScript基础总结5</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2017/07/07/5.JS RegExp/" data-id="cj4v4j6dq0019t8w981ibg3d4" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h1 id="10、RegExp"><a href="#10、RegExp" class="headerlink" title="10、RegExp"></a>10、RegExp</h1><blockquote>
<p>不是正则不重要（项目中很少用正则，面试也很少问正则），而是面试官不会</p>
<h2 id="1、正则是什么？如何学习？"><a href="#1、正则是什么？如何学习？" class="headerlink" title="1、正则是什么？如何学习？"></a>1、正则是什么？如何学习？</h2><p>正则就是由相关“元字符”和”修饰符“组成的一个规则用来匹配验证或者捕获字符串中某些内容的规则（正则仅仅用来处理字符串的）</p>
<ul>
<li>元字符</li>
<li>修饰符</li>
<li>编写常用的正则</li>
<li>正则的验证</li>
<li>正则的捕获</li>
<li>正则的一些小实战以及一些常规方法的封装：myOueryURLParameter 、 myTrim 、myFormatTime….<h4 id="test：正则的方法（-验证某一个字符串是否符合某一个规则）"><a href="#test：正则的方法（-验证某一个字符串是否符合某一个规则）" class="headerlink" title="test：正则的方法（ 验证某一个字符串是否符合某一个规则）"></a>test：正则的方法（ 验证某一个字符串是否符合某一个规则）</h4></li>
</ul>
</blockquote>
<h4 id="复习字符串中常用的方法"><a href="#复习字符串中常用的方法" class="headerlink" title="复习字符串中常用的方法"></a>复习字符串中常用的方法</h4><ul>
<li>charAt /charCodeAt  :根据索引获取指定位置的字符（或者字符的Unicode编码值）</li>
<li>String.fromCharCode([unicode编码])：通过指定的编码获取对应的字符</li>
<li>substr(n,m) :从索引n开始截取m个字符（m不写截取到结尾），n和m 不支持负数。。</li>
<li>substring(n,m): 从索引n开始找到索引为m处（不包含m)</li>
<li>slice（n,m):和substring一样，只是可以支持以负数作为索引（负数索引：总长度+负数索引，得到的结果就是查找的索引位置）</li>
<li>indexOf/lastIndexOf :找到字符在字符串中第一次或者最好一次出现位置的索引 如果没有这个字符 返回的是-1；（通过这个也可以判断当前的字符串中是否包含这个字符）</li>
<li>search：和indexOf相同，都是获取字符出现位置的索引  只是search可以支持正则</li>
<li>toLowerCase/toUpperCase:把一个字符串中的所有字符转换为大写或者小写</li>
<li>split：按照指定的分隔符，把一个字符串拆分成数组中的每一项 可以支持正则</li>
<li>replace：把字符串中的原有字符进行替换 在不使用正则的情况下，执行一次 –replace，值能替换一次，这个方法也可以支持正则</li>
<li>match：根据正则匹配到所有符合规则的结果，最后以数组来存储</li>
<li>localeCompare:两个字符之间的比较 ：按照每一个字符的Unicode编码值 一个个比较</li>
<li>repeat：重复！！！</li>
<li>trim/trimLeft/trimRight: 去除字符串的首尾空格（trimLeft去除首空格/trimRight去除为空格）但是这个方法不兼容</li>
</ul>
<h3 id="正则的元字符"><a href="#正则的元字符" class="headerlink" title="正则的元字符"></a>正则的元字符</h3><p>只要在/ ”元字符“/ 之间包含起来的  都是正则的元字符</p>
<ul>
<li>特殊元字符<ul>
<li>\   转义字符（把有意义的和没意义的字符来回转）</li>
<li>.   除了\n以外的任意字符</li>
<li>\n   换行符</li>
<li>^    以xxx开始，</li>
<li>$    以xxx结束</li>
<li>\d  匹配0-9之间的任意数字</li>
<li>\D  除了0-9之间数字的任意字符</li>
<li>\b   匹配一个边界符</li>
<li>\ w  匹配数字、字母、下划线中的任意字符</li>
<li>\ s   匹配一个空白字符</li>
<li>[xyz] x或者y或者z 中的一个  例如：[abacd]四个字母中的任意一个</li>
<li>[^xyz] 除了三个以外的任意字符</li>
<li>[a-z]  匹配a到z中的任意字符</li>
<li>[^a-z]  匹配除了a到z 中的任意字符</li>
<li>x|y   匹配x或者y中的任意一个</li>
<li>( )   分组</li>
<li>？:    只匹配不捕获</li>
<li>？=   正向预查</li>
<li>？！ 负向预查   这两个预查也起到了只匹配不捕获的作用</li>
<li>。。。</li>
</ul>
</li>
</ul>
<ul>
<li>量词元字符<ul>
<li><ul>
<li>出现零次或者多次</li>
</ul>
</li>
<li>? 出现零次或者一次</li>
<li><ul>
<li>出现一次或者多次</li>
</ul>
</li>
<li>{n} 出现n次</li>
<li>{n,} 出现n到多次</li>
<li>{n,m} 出现n 到m次</li>
</ul>
</li>
</ul>
<ul>
<li>普通元字符<br> 代表本身意思的元字符</li>
</ul>
<h3 id="正则的修饰符"><a href="#正则的修饰符" class="headerlink" title="正则的修饰符"></a>正则的修饰符</h3><ul>
<li>i  —-ignoreCase 忽略大小写</li>
<li>m —-multiline  匹配换行</li>
<li>g  —-global  全局匹配</li>
</ul>
<h3 id="while循环-（不知道循环的次数的情况下）"><a href="#while循环-（不知道循环的次数的情况下）" class="headerlink" title="while循环 （不知道循环的次数的情况下）"></a>while循环 （不知道循环的次数的情况下）</h3><h3 id="正则捕获的三种方法"><a href="#正则捕获的三种方法" class="headerlink" title="正则捕获的三种方法"></a>正则捕获的三种方法</h3><p>1、reg.exec(str)<br>2、str.match(reg)<br>3、str.replace(reg,function(){</p>
<p>})</p>
<h3 id="正则捕获的贪婪性：每一次捕获的结果都是当前正则匹配的最长结果-例如：2017符合-2也符合-但是捕获的是2017"><a href="#正则捕获的贪婪性：每一次捕获的结果都是当前正则匹配的最长结果-例如：2017符合-2也符合-但是捕获的是2017" class="headerlink" title="正则捕获的贪婪性：每一次捕获的结果都是当前正则匹配的最长结果 例如：2017符合 2也符合 但是捕获的是2017"></a>正则捕获的贪婪性：每一次捕获的结果都是当前正则匹配的最长结果 例如：2017符合 2也符合 但是捕获的是2017</h3><h2 id="？的5大作用："><a href="#？的5大作用：" class="headerlink" title="？的5大作用："></a>？的5大作用：</h2><p>1、放在一个普通的元字符后面，代表出现零到一次   —–量词元字符<br>2、放在一个量词元字符后面，代表取消正则捕获时候的贪婪性<br>3、 （？:） 设定当前分组只匹配不捕获<br>4、（？=）正向预查<br>5、（？！）负向预查 两个预查只起到了只匹配不捕获的作用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">手机号  var reg=/^1\d&#123;10&#125;/;</div><div class="line">身份证号 var reg=/^(\d&#123;6&#125;)(\d&#123;4&#125;)(\d&#123;2&#125;)(\d&#123;2&#125;)\d&#123;2&#125;(\d)(\d|X)$/</div><div class="line">密码  var reg=/^(?![0-9]+$)(?![a-zA-Z]+$)[a-zA-Z0-9]&#123;6,14&#125;$/;</div><div class="line">有效数字 var reg=/^[+-]?(\d|([1-9]\d+))(\.\d+)?$/</div><div class="line">名字  var reg=/^[\u4e00-\u9fa5]&#123;2,4&#125;$/</div><div class="line">年龄(16-76) var reg=/^1[6-9]|[2-6]\d|7[0-6]$/</div><div class="line">AXXB  var reg=/^[a-z]([a-z])\1$/</div><div class="line">ABBA  var reg=/^([a-z])([a-z])\2\1$/</div><div class="line">邮箱  var reg=/^\w+((-\w+)|(\.\w+))*@[a-zA-Z0-9]+((\.|-)[a-zA-Z0-9]+)*\.[a-zA-Z0-9]+$/</div><div class="line">出现一个数字 但不为3  var reg=/^((?!3)\d)+$/</div><div class="line"></div><div class="line">用户昵称  function checkNick(nick)&#123;</div><div class="line">          var reg1=/^[\u4e00-\u9fa5]&#123;6,14&#125;$/;</div><div class="line">          var reg2=/^\w$/;</div><div class="line">          var len=0;</div><div class="line">          for(var i=0;i&lt;nick.length;i++)&#123;</div><div class="line">           if(reg1.test(nick[i]))&#123;</div><div class="line">           len+=2;</div><div class="line">           &#125;</div><div class="line">           else(reg2.test(nick[i]))&#123;</div><div class="line">           len++;</div><div class="line">           &#125;</div><div class="line">           else&#123;</div><div class="line">           len=0;</div><div class="line">           break;</div><div class="line">           &#125;</div><div class="line">      &#125;</div><div class="line">      if(len===0||len&gt;14)&#123;</div><div class="line">      return false;</div><div class="line">      &#125;</div><div class="line">      return true;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2017/07/07/5.JS RegExp/">
    <time datetime="2017-07-07T04:46:54.667Z" class="entry-date">
        2017-07-07
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-4.JS json" class="post-4.JS json post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2017/07/07/4.JS json/">JavaScript基础总结4</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2017/07/07/4.JS json/" data-id="cj4v4j6b9000wt8w9q4j1lpf5" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h1 id="8、json"><a href="#8、json" class="headerlink" title="8、json"></a>8、json</h1><h2 id="JSON-一种数据格式，主要应用于前后端交互，前台向后台发送请求时，后台返回返回的基本是JSON格式的数据"><a href="#JSON-一种数据格式，主要应用于前后端交互，前台向后台发送请求时，后台返回返回的基本是JSON格式的数据" class="headerlink" title="JSON :一种数据格式，主要应用于前后端交互，前台向后台发送请求时，后台返回返回的基本是JSON格式的数据"></a>JSON :一种数据格式，主要应用于前后端交互，前台向后台发送请求时，后台返回返回的基本是JSON格式的数据</h2><h2 id="JSON对象和JSON字符串"><a href="#JSON对象和JSON字符串" class="headerlink" title="JSON对象和JSON字符串"></a>JSON对象和JSON字符串</h2><h3 id="1、JSON对象和JS对象类似，但是属性名必须用’””‘-双引号-包起来，属性值如果是字符串也要用双引号抱起来"><a href="#1、JSON对象和JS对象类似，但是属性名必须用’””‘-双引号-包起来，属性值如果是字符串也要用双引号抱起来" class="headerlink" title="1、JSON对象和JS对象类似，但是属性名必须用’””‘(双引号)包起来，属性值如果是字符串也要用双引号抱起来"></a>1、JSON对象和JS对象类似，但是属性名必须用’””‘(双引号)包起来，属性值如果是字符串也要用双引号抱起来</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var obj=&#123;name:&apos;zhufeng&apos;,age:8&#125;  普通对象</div><div class="line">var obj=&#123;&quot;name&quot;:”zhufeng&quot;,&quot;age&quot;:8&#125; JSON对象</div></pre></td></tr></table></figure>
<h3 id="2、JSON字符串"><a href="#2、JSON字符串" class="headerlink" title="2、JSON字符串"></a>2、JSON字符串</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var jsonStr=&apos;&#123;&quot;name&quot;:&quot;zhufeng&quot;,&quot;age&quot;:8&#125;&apos;</div><div class="line">var jsonStr=&apos;[  &#123;&quot;name&quot;:&quot;zhufeng&quot;,&quot;age&quot;:8&#125;  ]&apos;</div></pre></td></tr></table></figure>
<p>window上有一个JSON属性对象<br>提供了两个方法</p>
<blockquote>
<p>1、JSON.parse  将JSON格式的字符串转化为JSON格式的对象<br>var jStr1=JSON.parse(jsonStr1);</p>
<p>2、JSON.stringify  将普通格式/JSON格式的对象转化为JSON格式字符串<br>var objs={“name”:”zhufeng”,”age”:8}</p>
</blockquote>
<h3 id="在不兼容（不兼容IE6-7）的情况下-需要用到eval"><a href="#在不兼容（不兼容IE6-7）的情况下-需要用到eval" class="headerlink" title="在不兼容（不兼容IE6 -7）的情况下 需要用到eval"></a>在不兼容（不兼容IE6 -7）的情况下 需要用到eval</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var json1=&apos;&#123;&quot;name&quot;:&quot;zhufeng&quot;&#125;&apos;</div><div class="line">var date=eval(&apos;(&apos;+json1+&apos;)&apos;)</div></pre></td></tr></table></figure>
<h2 id="处理兼容性-将字符串转化为JSON对象"><a href="#处理兼容性-将字符串转化为JSON对象" class="headerlink" title="处理兼容性(将字符串转化为JSON对象)"></a>处理兼容性(将字符串转化为JSON对象)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var obj2=&apos;&#123;&quot;name&quot;:&quot;zhufeng&quot;&#125;&apos;</div><div class="line">var  sum=&quot;JSON&quot; in window？JSON.parse(obj2):eval(&apos;(&apos;+obj2+&apos;)&apos;);</div></pre></td></tr></table></figure>
<h2 id="简单交互"><a href="#简单交互" class="headerlink" title="简单交互"></a>简单交互</h2><ul>
<li>ajax :异步请求  局部刷新<br>需要XMLHttpRequest<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">var xhr=new XMLHttpRequest //生成了一个的实例  在这个实例里面提供了我们发送请求和接收数据的  属性方法</div><div class="line"></div><div class="line">1、要发送请求</div><div class="line">xhr.open(&apos;get&apos;,&apos;../date.txt&apos;,true)</div><div class="line">**//  获取方式  请求方式 get post</div><div class="line"> // 请求地址  &apos;../data.txt&apos;**</div><div class="line">2、xhr.onreadystatechange=function()&#123;</div><div class="line">  //监听请求&#125;</div><div class="line"> // readystate：0，1，2，3，4</div><div class="line">  //如果是4的话说明成功完成发送请求  如果请求成功  状态码 如果http请求成功发送请求  基本是200一些开头三位数也代表成功  通常访问一个不存在的网页，返回的http状态码 404；</div><div class="line">  status http 请求状态码</div><div class="line">  readyState ajax 状态码</div><div class="line">  if(this.readyState===4&amp;&amp;this.status==200)&#123;  console.log(xhr.responseText)</div><div class="line">   &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  xhr.send();  发送</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">2、监听请求响应（还需要判断是否成功，是否拿到数据）</div></pre></td></tr></table></figure>
</li>
</ul>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2017/07/07/4.JS json/">
    <time datetime="2017-07-07T04:42:47.184Z" class="entry-date">
        2017-07-07
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-6.js改变this" class="post-6.js改变this post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2017/07/07/6.js改变this/">JavaScript基础总结6</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2017/07/07/6.js改变this/" data-id="cj4v4j6bw000zt8w9t1h0jugs" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h1 id="7、改变this的指向"><a href="#7、改变this的指向" class="headerlink" title="7、改变this的指向"></a>7、改变this的指向</h1><p>1、所有的对象数据类型（普通对象 实例 prototype  函数）都是Object基类的一个实例<br>2、所有的函数数据类型（普通函数  类（内置类 自定义））都是Function的一个实例<br>3、所有的实例都是对象数据类型的，函数和类都是Function的实例，所以函数也是对象数据类型的值</p>
<h2 id="函数的多面性"><a href="#函数的多面性" class="headerlink" title="函数的多面性"></a>函数的多面性</h2><p>1、普通函数<br>执行的时候形成一个私有作用域  形参赋值  预解释  代码从上到下执行<br>2、作为一个类<br>具有原型链模式  类和实例的概念<br>3、作为一个对象<br>当做一个对象给他添加一个属性</p>
<blockquote>
<p>所有的函数数据类型（普通函数 类（内置类  自定义））都是Function的一个实例<br>每一个函数都可以使用Function的prototype上存储的属性和方法<br>Function的prototype上比较常用的几种属性（call/apply/bind(有兼容性)<br>每一个函数通过自己的<strong>proto</strong>找到、Function上的call方法<br>call的作用：<br>1、让方法中的this当做一个函数执行**<br>2、将call的this中的this修改为call的第一个参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">var obj=&#123;info:&apos;say&apos;&#125;;</div><div class="line">function fn()&#123;</div><div class="line">console.log(this)</div><div class="line">&#125;</div><div class="line">fn.call(obj)</div><div class="line">fn.call(obj)这里面fn是call的this，call方法让他执行也就是fn() 并且将fn中的this修改为call的第一个参数值obj   所以fn中的this被修改为obj</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">var obj=&#123;info:&apos;say&apos;&#125;;</div><div class="line">function fn(a,b)&#123;</div><div class="line">console.log(this)</div><div class="line">console.log(a,b)</div><div class="line">&#125;</div><div class="line">fn.call(obj,10,20)</div><div class="line">call语法</div><div class="line">函数.call([this].param1,param2....)第一参数作为call this中的this  其余后面一次是在给call的this传递的参数值</div><div class="line"></div><div class="line"></div><div class="line">1、&apos;use strict&apos;</div><div class="line">严格模式：</div><div class="line">让javaScript 在更加严格的方式下运行 ，如果call中第一个参数不传或者传的是null/undefined  方法中的this都是undefined  其余call中第一个参数是啥就是啥；</div><div class="line">2、非严格模式下：</div><div class="line">如果call中第一个参数不传或者传的是null/undefined 方法中this都是window 其余的call中第一个参数是啥就是啥</div></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="call-改变方法中的this关键字"><a href="#call-改变方法中的this关键字" class="headerlink" title="call 改变方法中的this关键字"></a>call 改变方法中的this关键字</h3><p>call的作用：<br>改变call “.”  前面方法中的this  并让前面的方法执行</p>
<h3 id="apply-修改方法中的this关键字"><a href="#apply-修改方法中的this关键字" class="headerlink" title="apply  修改方法中的this关键字"></a>apply  修改方法中的this关键字</h3><p>作用：<br>将apply ‘.’ 前面的this修改call中的第一个参数值<br>并让apply ‘.’  前面的this执行<br><strong>例如：fn.apply(arr2)   首先fn是apply的this   将fn中的this改为arr2  并让fn执行</strong></p>
<h3 id="bind-ie6-8"><a href="#bind-ie6-8" class="headerlink" title="bind (ie6~8)"></a>bind (ie6~8)</h3><p>预处理：事先将fn中的this修改为arr1  但并不会让fn执行，而是将改造后的fn当做值返回<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var arr1=[1,2,3]</div><div class="line">var arr2=[3,4,5]</div><div class="line">function fn(a,b)&#123;</div><div class="line">  console.log(this)</div><div class="line">  console.log(a,b)</div><div class="line">&#125;</div><div class="line">fn.call(arr1)</div><div class="line">var fe=fn.bind(arr1) fe接收的是this被改造后的fn</div><div class="line">fe()  改造后的fn执行</div></pre></td></tr></table></figure></p>
<h3 id="call和apply的区别"><a href="#call和apply的区别" class="headerlink" title="call和apply的区别"></a>call和apply的区别</h3><p>首先， call和apply都是改变方法中this关键字<br>不同：<br>call传参的时候是从第二个参数开始一个一个的传递<br>apply 把需要传递的参数值  放在一个数组里，也相当于一个一个将参数传递进去</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function fn1()&#123;console.log(&apos;f1&apos;)&#125;</div><div class="line">function fn2()&#123;console.log(&apos;f2&apos;)&#125;</div><div class="line">fn1.call(fn2); 让fn执行里面this修改为fn2</div><div class="line">fn1.call.call.call.call();每一个函数都可以使用Function.prototype上的call方法  因为call也是要给函数  所以就可以fn.call.call.call.call;</div></pre></td></tr></table></figure>
<h2 id="取出一个数组中的最大值-最小值"><a href="#取出一个数组中的最大值-最小值" class="headerlink" title="取出一个数组中的最大值 最小值"></a>取出一个数组中的最大值 最小值</h2><blockquote>
<p>var  ary=[1,2,3,4,5,6]<br>var max=Math.max.apply(null,[1,2,3,4,5,6])<br>var min=Math.min.apply(null,[1,2,3,4,5,6])<br>原理：利用apply传递参数的时候，是把需要传递的参数放在数组里，其实也是相当于一次性分别把数组中的每一个参数取出来  当做数组传递到我们方法中</p>
</blockquote>
<h2 id="取平均分"><a href="#取平均分" class="headerlink" title="取平均分"></a>取平均分</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"> function average()&#123;</div><div class="line">**  //    var ary=[];</div><div class="line">//      for(var //i=0;i&lt;arguments.length;i++)&#123;</div><div class="line">//           ary.push(arguments[i]);</div><div class="line">//       &#125;**</div><div class="line">        var ary=[].slice.call(arguments,0);</div><div class="line">        ary.sort(function(a,b)&#123;return a-b&#125;);</div><div class="line">        ary.length--;</div><div class="line">        ary.shift();</div><div class="line">        var sum=eval(ary.join(&apos;+&apos;));</div><div class="line">        var num=(sum/ary.length).toFixed(3);</div><div class="line">        return num;</div><div class="line">    &#125;</div><div class="line">    console.log(average(3,4,5,6,7,8,9,67,45,32));</div></pre></td></tr></table></figure>
<h3 id="js中捕获异常"><a href="#js中捕获异常" class="headerlink" title="js中捕获异常"></a>js中捕获异常</h3><p>  /<em>try catch finally<br>    如果try里面报错就会执行catch里面的代码<br>    finally不管报不报错  都会执行
    </em>/<br>  try{<br>      console.log(num);<br>  }catch(e){<br>      console.log(e,message);<br>//      throw new Error(e,message);<br>  }console.log(52);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">1题</div><div class="line"> var num = 0;</div><div class="line">    function Fn(num) &#123;</div><div class="line">        arguments[0] = 100;</div><div class="line">        this.num = 200;</div><div class="line">        console.log(num);</div><div class="line">        console.log(this.num);</div><div class="line">        return num;</div><div class="line">    &#125;</div><div class="line">    Fn.num = 400;</div><div class="line">    Fn.prototype.num = 300;</div><div class="line">    Fn.prototype.getNum = function () &#123;</div><div class="line">        console.log(this.num);</div><div class="line">    &#125;;</div><div class="line">    var f = new Fn(num);//</div><div class="line">    console.log(f.num);//</div><div class="line">    f.getNum();//</div><div class="line">    Fn.prototype.getNum();//</div><div class="line">    console.log(num);//</div><div class="line">    var n = Fn(num);//</div><div class="line">    console.log(n);//</div><div class="line">    console.log(num);//</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">2题</div><div class="line"> function Fn() &#123;</div><div class="line">        this.num=200;</div><div class="line">        num=300;</div><div class="line">        this.say=function () &#123;</div><div class="line">            this.num=15;</div><div class="line">            console.log(this.num);</div><div class="line">            console.log(Fn.num);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    var f1=new Fn;</div><div class="line">    Fn.prototype.num=100;</div><div class="line">    num=400;</div><div class="line">    Fn.num=111;</div><div class="line">    f1.say();</div><div class="line">    console.log(num);</div><div class="line">    console.log(f1.num);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">3题</div><div class="line">function Foo() &#123;</div><div class="line">getName = function () &#123; alert (1); &#125;;</div><div class="line">return this;</div><div class="line">&#125;</div><div class="line">Foo.getName = function () &#123; alert (2);&#125;;</div><div class="line">Foo.prototype.getName = function () &#123; alert (3);&#125;;</div><div class="line">var getName = function () &#123; alert (4);&#125;;</div><div class="line">function getName() &#123; alert (5);&#125;</div><div class="line">//请写出以下输出结果：</div><div class="line">Foo.getName();</div><div class="line">getName();</div><div class="line">Foo().getName();</div><div class="line">getName();</div><div class="line">new Foo.getName();</div><div class="line">new Foo().getName();</div><div class="line">new new Foo().getName();</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">4题</div><div class="line"> function text() &#123;</div><div class="line">    //        var n=666;</div><div class="line">    //        function add() &#123;</div><div class="line">    //            n++;</div><div class="line">    //            console.log(n);</div><div class="line">    //        &#125;</div><div class="line">    //        return &#123;n:n,add:add&#125;</div><div class="line">    //    &#125;</div><div class="line">    //    var r1 =text();</div><div class="line">    //    var r2=text();</div><div class="line">    //    r1.add();</div><div class="line">    //    r1.add();</div><div class="line">    //    console.log(r1.n);</div><div class="line">    //    r2.add();</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">5题</div><div class="line"> var num=1;</div><div class="line">    var obj=&#123;num:2&#125;;</div><div class="line">    obj.fn=(function(num)&#123;</div><div class="line">        this.num=num*2;</div><div class="line">        num++;</div><div class="line">        return function(n)&#123;</div><div class="line">            this.num+=n;</div><div class="line">            num++;</div><div class="line">            console.log(num);</div><div class="line">        &#125;</div><div class="line">    &#125;)(obj.num);</div><div class="line">    var fn=obj.fn;</div><div class="line">    fn(10); obj.fn(20);</div><div class="line">    console.log(num,obj.num);</div></pre></td></tr></table></figure>
      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2017/07/07/6.js改变this/">
    <time datetime="2017-07-07T04:38:55.674Z" class="entry-date">
        2017-07-07
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-3.JS3" class="post-3.JS3 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2017/07/07/3.JS3/">JavaScript基础总结3</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2017/07/07/3.JS3/" data-id="cj4v4j6cj0011t8w9si3ffgas" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p>JavaScript(JS)：一门轻量级的脚本“编程语言”</p>
<p>1、编程语言<br>C、C++、Java、PHP、.NET(dot net)、C#、ASP、ASP.NET、Python、Ruby、Go、VB、<br>JavaScript……</p>
<p>=》所有的编程语言都是面向对象开放的（C是面向过程的）</p>
<p>2、面向对象</p>
<ul>
<li>对象：万物皆对象，它是一个泛指</li>
<li>类：对象的一细分</li>
<li>实例：某一个类别中具体的事物</li>
</ul>
<p>生活中的例子：<br>我们生活在自然界中，自然界中的一切事物都是我们要研究的对象（统称为对象），而我们研究自然界的过程其实就是面向对象思想；自然界中把具有相同特点的进行分类（大类中包含小类），当我们需要研究的时候，只需要找出一个类别中的具体事物来研究即可，这个事物就是类的实例；</p>
<p>那么在JS中呢：<br>我们研究的JS中的一切事物都是对象，JS也是按照对象、类、实例三层体系架构实现的，JS把所有的东西按照特征分成了很多的大类和小类，我们要研究其中的某一个类，只需要研究里面的一个实例即可</p>
<p>Math</p>
<h4 id="gt-学习面向对象"><a href="#gt-学习面向对象" class="headerlink" title="=&gt;学习面向对象"></a>=&gt;学习面向对象</h4><p>1）学会自己创建类和实例<br>2）掌握原型机制（掌握实例和类的关系）<br>3）掌握类的继承、封装、多态<br>4）基于面向对象思想封装组件插件等</p>
<h3 id="1-面向对象"><a href="#1-面向对象" class="headerlink" title="1.面向对象"></a>1.面向对象</h3><p><strong>研究数组</strong><br>创建数组类Array的一个实例（创建数组）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var ary = [12,23];//-&gt;字面量创建方式</div><div class="line">var ary2 = new Array(&apos;12&apos;);//-&gt;实例创建方式（面向对象创建）</div><div class="line">//new Array(12) 括号中的数字是设定数组的长度，而不是给增加值</div><div class="line">//new Array(&apos;12&apos;)这样才是给数组第一项设定为12，数组有一项</div><div class="line">//new Array(12,23)这样数组有两项，分别是12和23</div><div class="line">console.dir(ary);</div><div class="line">console.dir(ary2);</div></pre></td></tr></table></figure></p>
<h3 id="2-创建类"><a href="#2-创建类" class="headerlink" title="2.创建类"></a>2.创建类</h3><p>创建的类第一个字母最好大写<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function Person()&#123;</div><div class="line">	  //看不见：var obj=&#123;&#125;  this-&gt;obj</div><div class="line">	  //看不见：return obj;/return this;</div><div class="line">&#125;</div><div class="line">	var a = Person();//-&gt;此时的Person仅仅是一个普通的函数，走的是函数那一套流程：创建私有的作用域-&gt;赋值/预解释-&gt;依次执行代码（私有变量还是全局变量=&gt;作用域链）-&gt;作用域是否销毁“生命周期”</div><div class="line">	console.log(a);//-&gt;undefined 因为函数执行的时候没有返回值</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function Person()&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">var p = new Person();</div><div class="line">console.log(p);</div></pre></td></tr></table></figure>
<p><code>var p = new Person()</code>-&gt;这样执行Person就是一个类了，它的执行步骤：<br>1.也和普通函数执行一样，创建一个私有的作用域，进行形参赋值和预解释<br>2.new 这样执行，在预解释完成后，浏览器会默认的在私有作用域中创建一个对象，而且函数中的this就指向这个对象<br>3.然后在和普通函数一样，代码从上到下执行（作用域链）<br>4.new 这样执行，在代码执行完成后，会默认的把第二步中我们创建的这个对象返回</p>
<blockquote>
<p>这种执行方式叫做构造函数模式，new Person( )  Person就是一个类（自定义类），而返回的结果P就是当前类的一个实例</p>
<p><strong>this 问题</strong><br>  普通函数执行，方法中的this取决于函数执行的时候前面是否有点“.”，有的话点前面是谁this就指向谁，没有的话this指向window</p>
<ul>
<li>构造函数模式下，方法中的this指向的是当前类的一个实例</li>
</ul>
</blockquote>
<h4 id="小试牛刀"><a href="#小试牛刀" class="headerlink" title="小试牛刀"></a>小试牛刀</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function Student(name,age) &#123;</div><div class="line">	this.name = name;</div><div class="line">	this.age = age;</div><div class="line">&#125;</div><div class="line">var st1 = new Student(&apos;赵薇&apos;，72)；</div><div class="line">var st2 = new Student(&apos;小燕子&apos;，16)；</div><div class="line">console.log(st1);</div></pre></td></tr></table></figure>
<p>student( );普通函数执行；<br>student；函数的一个定义体（函数本身）<br>var st2 = new Student;  在构造函数模式执行的时候，如果不需要传递参数，后面的小括号可加可不加，没什么区别；</p>
<blockquote>
<p>通过构造函数创建出来的实例都是相互独立的个体，互相不影响，而在构造函数体中写的this.xxx = xxx都相当于在给当前的实例增加增加属于自己的私有属性</p>
<ul>
<li>类的数据类型：函数数据类型  typeof Student=&gt;’function’</li>
<li>实例数据类型： 对象数据类型 typeof st1=&gt;’object’</li>
</ul>
</blockquote>
<p><img src="./3-小试牛刀.png" alt="Alt text"></p>
<h4 id="登堂入室"><a href="#登堂入室" class="headerlink" title="登堂入室"></a>登堂入室</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function Fn(name) &#123;</div><div class="line">	var school =&apos;大学&apos;;//-&gt;school仅仅是私有作用域中的一个私有变量，在函数体中只有this.xxx=xxx才是在给实例设置私有的属性，而私有的变量和实例没有必然的联系</div><div class="line">	this.name = name;</div><div class="line">	this.say = function () &#123;</div><div class="line">		console.log(&apos;my name is&apos; + this.name +&apos;,i study in the&apos; + school);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">var f1 = new Fn(&apos;赵薇&apos;);</div><div class="line">var f2 = new Fn(&apos;小燕子&apos;);</div><div class="line">console.log(f1.name);//赵薇</div><div class="line">f1.say( );//this指向f1 //my name is 赵薇，i study in the 珠峰</div><div class="line">console.log(f1.say === f2.say);//false 实例之间是相互独立的，this.xxx=xxx其实是给实例增加的私有的属性</div><div class="line">console.log(f1.school);//undefined 属性名不存在，获取的结果是undefined，而不是报错 =&gt;函数具备多种角色：普通函数、类、不同的角色之间没有必然的联系</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function Fn(name)&#123;</div><div class="line">	var school = &apos;大学&apos;;</div><div class="line">	this.name = name;</div><div class="line">	this.say = function ()&#123;</div><div class="line">		console.log(&apos;my name  is&apos; + this.name + &apos;,i study in the &apos; +school );</div><div class="line">	&#125;</div><div class="line">	return 1;</div><div class="line">&#125;</div><div class="line">var f1 = new Fn(&apos;赵薇&apos;);</div><div class="line">console.log(f1);//赵薇 -&gt;实例：如果我们返回的结果是一个基本数据类型值，对最后的实例没有任何的影响</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function Fn(name)&#123;</div><div class="line">	var school = &apos;大学&apos;;</div><div class="line">	this.name = name;</div><div class="line">	this.say = function()&#123;</div><div class="line">		console.log(&apos;my name is&apos;+this.name+&apos;,i study in the&apos;+school);</div><div class="line">	&#125;;</div><div class="line">	return&#123;name:&apos;大学&apos;&#125;;//没有return返回赵薇</div><div class="line">&#125;</div><div class="line">var f1 = new Fn(&apos;赵薇&apos;);</div><div class="line">console.log(f1);//大学 -&gt;新的对象：如果我们手动返回的结果是一个引用数据类型的值，会把默认返回的实例给覆盖掉，此时的f1就不是类的实例了</div><div class="line">console.log(&apos;say&apos; in f1);//true-&gt;检测say是否为f1的一个属性</div><div class="line">console.log(f1.hasOwnProperty(&apos;say&apos;));//true;-&gt;hasOwnProperty:检测属性是否为对象（实例）的私有属性</div></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>in:不管当前的属性是私有的还是公有的，只有有返回值的结果就是true</li>
<li>hasOwnProperty: 只有是私有的属性才会返回true，即使你公有里面有这个属性，但是如果私有中没有，返回结果也是false</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function Fn(name)&#123;</div><div class="line">	var school = &apos;大学&apos;；</div><div class="line">	this.name = name;</div><div class="line">	this.say = function ()&#123;</div><div class="line">		console.log(&apos;my name is&apos;+ this.name +&apos;,i study in the&apos; +school)</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">var f1 = new Fn(&apos;赵薇&apos;);</div><div class="line">//检测某一个对象是否拥有某一个公有的属性：检测attr是否为obj的公有属性</div><div class="line">function hasPublicProperty(obj,attr) &#123;</div><div class="line">	return (attr in obj) &amp;&amp; !obj.hasOwnProperty(attr);//满足条件attr是obj的一个属性并且不是私有的属性</div><div class="line">&#125;</div><div class="line">console.log (hasPublicProperty(f1,&apos;say&apos;));//false</div></pre></td></tr></table></figure>
<h4 id="5-单例模式的误区"><a href="#5-单例模式的误区" class="headerlink" title="5.单例模式的误区"></a>5.单例模式的误区</h4><p><strong>单例模式</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var personRender = &#123;&#125;;</div><div class="line">var studentRender =(function()&#123;</div><div class="line">	return&#123;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;) ();</div></pre></td></tr></table></figure></p>
<p><strong>构造函数模式</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function Person()&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">var p = new Person();</div></pre></td></tr></table></figure></p>
<p><strong>什么叫做闭包</strong><br>函数执行形成一个私有的作用域=》闭包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function fn()&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">fn()</div></pre></td></tr></table></figure></p>
<p>闭包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">(function () &#123;</div><div class="line"></div><div class="line">&#125;) ();</div><div class="line">function fn()&#123;</div><div class="line">	return function()&#123;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">var f= fn();</div></pre></td></tr></table></figure></p>
<h3 id="6-原型模式"><a href="#6-原型模式" class="headerlink" title="6.原型模式"></a>6.原型模式</h3><p><strong>以下的几句话不要管为什么，因为他们是规定</strong></p>
<ul>
<li><p>每一个函数数据类型（普通函数、类（内置类、自定义类））都天生自带一个属性prototype,这个属性的属性值是一个对象数据类型的结果<code>Person.prototype=&gt;{ }</code></p>
</li>
<li><p>prototype对应的对象中，有一个天生自带的属性：constructor(构造函数)     这个属性的属性值指向的是当前函数本身 <code>Person.prototype=&gt;{constructor:Person}</code></p>
</li>
<li>每一个对象数据类型（普通对象、实例、prototype、函数也是对象）都有一个天生自带的属性：<code>_proto_</code>，这个属性指向自己所属类的原型(prototype)</li>
<li>类的原型（prototype）上存储的属性和方法都是实例公有的属性方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">function Person(name)&#123;</div><div class="line">//this.xxx=xxx都是实例的私有属性</div><div class="line">	this.name = name;</div><div class="line">	this.say = function ()&#123;</div><div class="line">		console.log(&apos;my name is&apos;+this.name);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">var p1 =new Person(&apos;韩晴晴&apos;);</div><div class="line">var p2 = new Person(&apos;赵薇&apos;);</div><div class="line"></div><div class="line"></div><div class="line">Person.prototype.drink=function()&#123;</div><div class="line">	console.log(&apos;cheers!&apos;)</div><div class="line"> &#125;</div><div class="line"> console.log(p1.say===p2.say);//false</div><div class="line"> console.log(p1.drink===p2.drink);//true</div><div class="line"> console.log(p1.hasOwnProperty(&apos;drink&apos;))//false</div><div class="line"> console.log(&apos;drink&apos; in p1);//true</div><div class="line"> p1.drink( );//cheers!</div><div class="line"> p1._proto_.drink(); //cheers!跳过了私有的查找，直接的找原型上的公有属性</div></pre></td></tr></table></figure>
<p><strong>原型链的机制<em>*</em></strong><br><code>p1.drink( );</code>//<br>先找自己私有的属性，如果私有的属性中没有drink，则继续到所属类的原型上查找。。一直找到Object.prototype为止=》这种查找的机制叫做<strong>原型链</strong></p>
<p><code>p1._proto_.drink( )</code>//跳过了私有的查找，直接的找原型上的公有属性<br><code>p1.hasOwnProperty()</code> this指向p1;<br><code>p1._proto_.hasOwnProperty()</code> this指向p1.<em>proto</em> (Person.prototype)<br><code>p1._proto_._proto_.hasOwnProperty()</code> this指向<code>p1._proto_.proto_(object.prototype)</code>=&gt;Object.prototype.hasOwnProperty( )=&gt;让Object原型上的hasOwnProperty方法执行</p>
<p><strong>通过以上三种方法，我们都可以把hasOwnProperty方法执行，但是有所区别：方法执行的时候，方法中的this是不一样的；在万恶的IE浏览器下，为了保护原型，屏蔽了我们使用<code>_proto_</code>这个属性</strong><br><img src="./6-原型模式.png" alt="Alt text"></p>
<h3 id="7-原型进阶"><a href="#7-原型进阶" class="headerlink" title="7.原型进阶"></a>7.原型进阶</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function Fn()&#123;</div><div class="line">	this.n = 100;</div><div class="line">&#125;</div><div class="line">Fn.prototype.m = 200;</div><div class="line">var f = new Fn();</div><div class="line">console.log(f.hasOwnProperty(&apos;n&apos;));//true</div></pre></td></tr></table></figure>
<p>//-&gt;在内置类的原型上扩展一个方法：如果这个方法之前人家有，我们这样操作会把之前的覆盖掉，这样非常不好，所以我们在取方法名的时候最好加一个特殊的前缀”my”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Object.prototype.myHasPublicProperty = function myHasPublicProperty()&#123;</div><div class="line">			//-&gt;this 需要处理的那个实例（对象）</div><div class="line">	var attr = arguments[0];</div><div class="line">	return (attr in this) &amp;&amp; !this.hasOwnProperty(attr);</div><div class="line">&#125;;</div><div class="line">console.log(f.myHasPublicProperty(&apos;m&apos;)); //true</div></pre></td></tr></table></figure></p>
<p>//-&gt;思考题：<br>数组中存在一个方法slice，在一个数组中进行查找，找到我们需要的部分，最后返回一个新数组，原来数组不变<br>ary.slice（）<br>ary.slice( n)<br>ary.slice(n,m)<br>如果n或者m或者两者都是负数<br>如果是小数呢<br>如果是非有效数字呢<br>如果传递的n&gt;m呢<br>如果传递的n或者m或者两者都大于最大长度呢<br>…</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Array.prototype.mySlice = function mySlice() &#123;</div><div class="line">        /*实现你的代码，完成和内置slice一模一样的功能：要求尽可能的考虑更多情况、不能使用数组中内置的方法*/</div><div class="line">        //return this.slice.apply(this, arguments); X</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="8-原型进阶-链式写法"><a href="#8-原型进阶-链式写法" class="headerlink" title="8.原型进阶-链式写法"></a>8.原型进阶-链式写法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var ary =[12, 23, 34, 11, 35, 24, 56];</div><div class="line">var newAry = ary.sort(function (a,b))&#123;</div><div class="line">	return a - b;</div><div class="line">&#125;</div><div class="line">console.log(ary); //会把原数组改变[11, 12, 23, 24, 34, 35, 56]</div><div class="line">console.log(newAry);//也有返回值，返回的结果时改变后的数组[11, 12, 23, 24, 34, 35, 56]</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var ary = [12, 23, 34, 11, 35, 24, 56];</div><div class="line">	var newAry = ary.sort(function (a,b)&#123;</div><div class="line">		return a-b;</div><div class="line">	&#125;);</div><div class="line">	newAry = newAry.slice（0，3);</div><div class="line">	console.log(newAry);   //[11,12,23]</div></pre></td></tr></table></figure>
<p>链式写法：需要保证每一次执行方法返回的结果依然是当前类的一个实例，这样就可以继续调取原型上的方法了…<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">ary.sort(function (a, b) &#123;</div><div class="line">       return a - b;</div><div class="line">   &#125;).slice(0, 3).reverse().push(100).pop();//-&gt;Uncaught TypeError: ary.sort(...).slice(...).reverse(...).push(...).pop is not a function 执行PUSH方法后，返回的结果是新增后数组的长度，是一个数字，不能在继续调取Array.prototype上的方法了</div><div class="line"></div><div class="line">   Array.prototype.mySlice = function mySlice() &#123;</div><div class="line"></div><div class="line">       return this;//-&gt;实现链式写法最简单的方式，就是在每一个方法执行完成后返回THIS即可，因为方法中的THIS就是当前类的实例</div><div class="line">   &#125;;</div><div class="line">   ary.mySlice().push();</div><div class="line"></div><div class="line"></div><div class="line">   /*思考题</div><div class="line">    *  (5).plus(3).minus(2)  =&gt;6  在Number的原型上扩展方法:plus和minus不仅可以实现加减操作而且还可以实现链式写法</div><div class="line">    */</div></pre></td></tr></table></figure></p>
<blockquote>
<p>Math不是类，它仅仅是一个对象，’Math’ in window=&gt;TRUE 它是window全局对象的一个属性而已，这个对象中包含了很多的方法，供我们操作数字，所以我们把它称之为“数学函数”</p>
</blockquote>
<p>Math.abs()<br>Math.ceil()<br>Math.floor()<br>Math.round()<br>Math.random()<br>Math.round(Math.random()*(m-n)+n)<br>Math.max()<br>Math.min()<br>Math.PI   3.141592653…<br>Math.pow(n,m) 获取n的m次幂 =&gt;Math.pow(5,3) -&gt;125<br>Math.sqrt(n) 给n开平方 =&gt;Math.sqrt(100) -&gt;10<br><img src="./JS类的构建体系图.png" alt="Alt text"></p>
<h3 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h3><ul>
<li>所有的函数数据类型（普通函数 类（自定义 内置）），都是Function这个类的实例</li>
<li>所有实例都是对象数据类型的，函数也是对象数据类型的</li>
<li>对象数据类型都有一个天生自带的属性<em>proto</em>指向所属类的原型</li>
<li>因为函数也是对象数据类型的 我们的Function（内置类）它也是函数数据类型，所以它也是对象数据类型的 每一个对象数据类型都有一个天生自带的属性<em>proto</em>,</li>
<li>Function是一个内置类，类都是函数数据类型 所有函数数据类型都是Function这个内置类的实例；所以Function作为一个类一个对象数据类型，它的<em>proto</em>指向所属类的原型Function的prototype也就是Function自己的prototype</li>
<li>object是一个基类，js中最顶层的类，类都是函数数据类型 函数也是对象数据类型 那么object也有一个天生自带的属性<em>proto</em>,因为object也是函数数据类型的，它的—proto—指向的Function的prototype</li>
</ul>
<h3 id="重构对象原型"><a href="#重构对象原型" class="headerlink" title="重构对象原型"></a>重构对象原型</h3><p>每个类天生自带的属性 浏览器为它开辟了一个堆内存 里面有一个天生自带的属性constructor，constructor指当前函数（类）的本身</p>
<p>重构原型对象 自己开辟的堆内存 来存储公有的属性和方法 将浏览器天生为Fn.prototype开辟的堆内存替换掉</p>
<p>f1.constructor 由于我们为Fn.prototype新开辟了一个堆内存，所以最终通过原型链查找，找到的是Object.prototype上constructor =&gt;object</p>
<p>只有浏览器天生为Fn.prototype开辟的堆内存才有constructor这个属性，我们自己开辟的堆内存没有constructor没有这个属性prototype开辟的堆内存里添加constructor指向Fn</p>
<p>我们为了和原来一样就自己手动在 自己为Fn.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Fn.prototype = &#123;</div><div class="line">        constructor: Fn,</div><div class="line">        y: 10</div><div class="line">    &#125;;</div><div class="line">    var f1 = new Fn;</div><div class="line">    console.log(Fn.prototype);</div><div class="line">    console.log(f1.constructor)</div></pre></td></tr></table></figure>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2017/07/07/3.JS3/">
    <time datetime="2017-07-07T03:59:46.511Z" class="entry-date">
        2017-07-07
    </time>
</a>
    
    
    </footer>
</article>






  
  
    <nav id="pagination">
      <nav id="page-nav">
        <a class="extend prev" rel="prev" href="/page/4/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/6/">Next &raquo;</a>
      </nav>
    </nav>
  

</div></div>
        <div id="secondary" class="widget-area" role="complementary">
  
    <aside id="search" class="widget widget_search"><form role="search" method="get" accept-charset="utf-8" id="searchform" class="searchform" action="//google.com/search">
    <div>
        <input type="text" value="" name="s" id="s" />
        <input type="submit" id="searchsubmit" value="搜索" />
    </div>
</form></aside>
  
    
  
    
  
    
  <aside class="widget">
    <h3 class="widget-title">Recents</h3>
    <div class="widget-content">
      <ul>
        
          <li>
            <a href="/2017/07/08/mobile3/">移动端总结-3</a>
          </li>
        
          <li>
            <a href="/2017/07/08/HTML5+CSS3/11/">11.html5+css3</a>
          </li>
        
          <li>
            <a href="/2017/07/08/HTML5+CSS3/10/">10.html5+css3</a>
          </li>
        
          <li>
            <a href="/2017/07/08/HTML5+CSS3/9/">9.html5+css3</a>
          </li>
        
          <li>
            <a href="/2017/07/08/HTML5+CSS3/8/">8.html5+css3</a>
          </li>
        
      </ul>
    </div>
  </aside>

  
    
  
    
  
</div>
      </div>
      <footer id="colophon" role="contentinfo">
    <p>&copy; 2017 John Doe
    All rights reserved.</p>
    <p>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></p>
</footer>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"1","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"16"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>

<script src="/js/jquery-2.0.3.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

<script src="/js/navigation.js"></script>

<div id="bg"></div>

  </div>
</body>
</html>